<!doctype html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<title>Solution UI</title>
		<link rel="stylesheet" href="css/bootstrap.min.css">
		<link rel="stylesheet" href="css/common.css">
		<link rel="stylesheet" href="css/style.css">
		<link rel="stylesheet" href="css/hover.css">
		<link rel="stylesheet" href="css/pretendard.css">

		<script src="js/jquery.min.js"></script>
		<script src="js/graph-sample.js"></script>
		<script src="js/bootstrap.bundle.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gridstack@10.1.2/dist/gridstack.min.css">
		<script src="https://cdn.jsdelivr.net/npm/gridstack@10.1.2/dist/gridstack-all.js"></script>
		<script src="js/icon.js"></script>
		<style>
		/* Dashboard 전용 CSS */
			body{--c-main-sub1:rgba(255, 116, 116, 0.1);}
			html, body {overflow-x: auto !important;}
			.demobox {height:250px;border:1px solid rgba(255,255,255,0.1);padding:10px 5px;overflow-y: hidden !important;}
			.demobox > .ztna{animation:demoAnimation1 7s infinite alternate ease-in-out;}
			.dash-title{font-size:1.05em; color:var(--c-text) !important; font-weight:500;}
			.demotable .demofont{width:120px;font-size:3em !important;font-weight:600;padding-top:0px;}
			.demotable .demofont.off{font-weight:300;color:var(--c-ligray2) !important;}
			.dash-count{font-size:3em !important;font-weight:600;text-align:center;padding:15px 0;}
			.demotable{margin:10px 0;padding:0;}
			.demotable tr td{line-height:22px;padding:0;height:22px !important;}
			.demotable td.right{cursor: pointer; transition: opacity 0.2s ease;}
			.demotable td.right:hover{opacity: 0.7;}
			.demotable td.fc-gray{cursor: pointer; position: relative; padding-left: 20px !important;}
			.demotable td.fc-gray.selected{
				padding-left: 20px !important;
			}
			.demotable td.fc-gray.selected::before{
				content: "\f00c";
				font-family: "Font Awesome 5 Free";
				font-weight: bold;
				position: absolute;
				left: 0;
				color: var(--c-main);
			}
			.demotable td.fc-gray.filter-option {
				transition: all 0.2s ease;
			}
			.demotable td.fc-gray.filter-option:hover {
				opacity: 0.7;
			}
			.demotable td.fc-gray.filter-option.selected {
				color: var(--c-main) !important;
			}
			.demotable td.fc-gray.filter-option.selected::before {
				content: "\f00c";
				font-family: "Font Awesome 5 Free";
				font-weight: bold;
				position: absolute;
				left: 0;
				color: var(--c-main);
			}
			.back{overflow-y: scroll;}
			.back::-webkit-scrollbar {width: 2px;height:100%;}
			.back::-webkit-scrollbar-thumb  {background-color: var(--c-main) !important;height:10% !important;border-radius:3px;}
			.back::-webkit-scrollbar-track  {background-color:var(--c-posi) !important;}
			.back .table thead th, .back .table tr td {font-size:12px !important; font-weight:300;text-align:center;}
			.dash-title{font-size:1em;text-align:left;font-weight:500;margin-top:0;line-height:1.2em;color:var(--c-gray) !important;}
			.dash-title .error{display:inline-block;border-radius:3px;vertical-align: middle;padding:0 5px;background-color:var(--c-red); color:#FFF;font-size:0.8em;}
			.dashbox{position: relative;min-height:180px;transition: min-height 0.3s ease, height 0.3s ease;margin-bottom: 20px;
				border:1px solid var(--border-content) !important;overflow-y: hidden !important;}
			.dash-stitle{position:absolute;bottom:20px; height:50px;}
			.dashbox.collapsed{min-height:140px !important; height: 140px !important;margin-bottom: 20px;overflow-x: hidden !important;}
			/* bg-content가 collapsed일 때 높이 조정 (시스템 리소스 영역은 #chart-body .bg-content.collapsed로 별도 관리) */
			.bg-content.collapsed{min-height:140px !important; height: 140px !important;overflow: hidden !important;}
			.grid-stack-item-content .bg-content.collapsed{min-height:185px !important; height: 185px !important;overflow: hidden !important;}
			.dashbox .accordion{transition: opacity 0.3s ease, max-height 0.3s ease, height 0.3s ease;
				overflow: hidden !important;max-height: 500px;height: auto;position: relative;}
			.dashbox .accordion.collapsed{max-height: 0 !important; height: 0 !important; opacity: 0; padding: 0 !important; margin: 0 !important;overflow: hidden !important;}
			
			/* GridStack 아이템에서 아코디언 높이 조정 */
			.grid-stack-item-content .dashbox.collapsed {
				height: 185px !important;
				min-height: 185px !important;
				overflow: hidden;
			}
			
			.grid-stack-item.collapsed-height-1 .grid-stack-item-content {
				overflow: hidden !important;
			}
			
			/* GridStack 아이템 높이 직접 조정 - 185px로 강제 설정 */
			.grid-stack-item.collapsed-height-1 {
				height: 185px !important;
				min-height: 185px !important;
			}
			
			.grid-stack-item.collapsed-height-1 .grid-stack-item-content {
				height: 185px !important;
			}
			
			.grid-stack-item-content .dashbox.collapsed .dash-title {
				position: absolute;
				top: 50%;
				left: 50%;
				transform: translate(-50%, -50%);
				margin: 0;
				width: 100%;
				text-align: center;
				z-index: 10;
			}
			.dot{display:inline-block;width:10px; height:10px; border-radius:50%;vertical-align: middle;margin-left:10px;}
			.dot.ok{background-color:var(--c-green);}
			.dot.error{background-color:var(--c-red);animation:demoAnimation1 1s infinite alternate ease-in-out;}
			.dash-graph-box{height:190px;}
			.dash-graph-box canvas{height:180px !important; width: 100% !important;}
			.dash-table-box{height:75px;}
			
			/* 그래프 컨테이너 스타일 개선 */
			canvas {
				display: block !important;
				max-width: 100% !important;
				max-height: 100% !important;
			}
			
			/* 시스템 리소스 차트 스타일 */
			#systemResourceChart {
				width: 100% !important;
				height: 300px !important;
				display: block !important;
				position: relative !important;
			}
			
			/* 트래픽 차트 스타일 */
			#iamTrafficChart, #ztnaTrafficChart, #siteAccessChart, #infoLeakChart, #swgBlockChart, #ztnaBlockChart, #harmfulBlockSystemChart {
				width: 100% !important;
				height: 180px !important;
				display: block !important;
				position: relative !important;
			}
			
			/* 유해물 차단현황 및 정보유출 감시 현황 그래프 높이 증가 */
			#harmfulBlockChart, #casbBlockChart {
				width: 100% !important;
				display: block !important;
				position: relative !important;
			}
			
			/* AI 사용량 차트 스타일 */
			#aiTotalUsageChart {
				width: 100% !important;
				height: 250px !important;
				display: block !important;
				position: relative !important;
			}
			
			/* 차트 컨테이너 개선 */
			.dash-graph-box {
				position: relative !important;
				width: 100% !important;
				height: 180px;
				overflow: hidden !important;
				display: flex !important;
				align-items: center !important;
			}
			
			/* 단일 차트인 경우에만 absolute positioning 적용 (직접 자식인 canvas) */
			.dash-graph-box > canvas {
				position: absolute !important;
				top: 0 !important;
				left: 0 !important;
				width: 100% !important;
				height: 100% !important;
			}
			
			/* 원그래프와 선 그래프를 감싸는 div 스타일 */
			.dash-graph-box > div {
				position: relative !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
				height: 180px !important;
			}
			
			/* 원그래프 컨테이너 (30% 너비) */
			.doughnut-chart-container {
				width: 30% !important;
				height: 180px !important;
				min-height: 180px !important;
				flex-shrink: 0 !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
			}
			
			/* 선 그래프 컨테이너 (70% 너비) */
			.line-chart-container {
				width: 70% !important;
				height: 180px !important;
				min-height: 180px !important;
				flex-shrink: 0 !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
			}
			
			/* 원그래프와 선 그래프를 감싸는 div 내부의 canvas */
			.dash-graph-box > div canvas {
				position: relative !important;
				width: 100% !important;
				height: 180px !important;
				max-height: 180px !important;
			}
			
			/* 원그래프 canvas 특별 스타일 */
			#iamTrafficDoughnutChart, #ztnaTrafficDoughnutChart {
				height: 140px !important;
				max-height: 140px !important;
				width: 100% !important;
			}
			
			/* 선 그래프 canvas 특별 스타일 */
			#iamTrafficChart, #ztnaTrafficChart, #siteAccessChart, #infoLeakChart {
				height: 180px !important;
				max-height: 180px !important;
				width: 100% !important;
			}
			@keyframes demoAnimation3 {
			  0% {opacity:100%;width:14px; height:14px;top:6px; right:6px;}
			  50% {opacity:100%;}
			  51% {opacity:0%;width:12px; height:12px;}
			  100% {opacity:0%;}
			}
			@keyframes demoAnimation2 {
			  0% {background-color:rgba(255,0,24,0.5);}
			  60% {background-color:rgba(255,0,24,0.1);}
			  90% {background-color:var(--bg-content);}
			  100% {background-color:var(--bg-content);}
			}
			.dashbox.error{animation:demoAnimation2 1s infinite alternate ease-in-out;border:1px solid var(--c-red) !important;}
			
			/* 시스템 접속 현황 클릭 가능한 제목 스타일 */
			.clickable-title {
				cursor: pointer;
				transition: color 0.3s ease;
				user-select: none;
			}
			
			.clickable-title:hover {
				color: var(--c-main);
			}
			
			/* front/back 화면 전환 애니메이션 */
			.front, .back {
				transition: opacity 0.3s ease, transform 0.3s ease;
			}
			
			.front {
				opacity: 1;
				transform: translateY(0);
				display: block;
				position: relative;
				width: 100%;
				height: 100%;
			}
			
			.back {
				opacity: 0;
				transform: translateY(10px);
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				z-index: 1;
				visibility: hidden;
				pointer-events: none;
				padding: 0;
				box-sizing: border-box;
			}
			
			.back.show {
				opacity: 1;
				transform: translateY(0);
				display: block;
				visibility: visible;
				pointer-events: auto;
			}
			
			.front.hide {
				opacity: 0;
				transform: translateY(-10px);
				display: block;
				position: absolute;
				top: 0;
				left: 0;
				width: 100%;
				height: 100%;
				visibility: hidden;
				pointer-events: none;
			}
			
			/* 클릭 가능한 영역 표시 */
			.front, .back {
				cursor: default;
				transition: opacity 0.3s ease, transform 0.3s ease;
			}
			
			/* 타이틀 클릭 가능 스타일 */
			.dash-title {
				cursor: pointer;
				transition: color 0.3s ease;
			}
			
			.dash-title:hover {
				color: var(--c-main) !important;
			}
			
			/* front/back 컨테이너 스타일 */
			.accordion {
				position: relative;
				overflow: hidden;
				min-height: 180px;
			}
			.table thead th{height:25px !important;padding:3px 0;}
			#iamBlockChart{height:160px !important; max-height:160px !important;}
			.iam, .ztna, .swg, .casb{margin-bottom:20px;}
			.w50p > .c-box{height:300px;}
			.chart-bar{height:100%;}
			.g10{gap:10px;}
			
			/* 가로 비율 조정: 전체를 9로 나눠서 시스템 리소스 1, 나머지 8 */
			.w-system-resource {width: 11.111111% !important;} /* 1/9 */
			.w-main-content {width: 88.888889% !important;} /* 8/9 */
			
			/* 왼쪽 시스템 리소스 영역 높이 고정 */
			#chart-body {
				display: flex;
				flex-direction: column;
				margin-top:3px;
			}
			
			#chart-body .vstack {
				flex: 1;
				display: flex;
				flex-direction: column;
			}
			
			#chart-body .bg-content {
				display: flex;
				flex-direction: column;
				height: 786px;
				min-height: 786px;
			}
			
			/* 시스템 리소스 영역 접었을 때 높이 - 프로그레스 바들이 모두 보이도록 충분한 높이 확보 */
			#chart-body .bg-content.collapsed {
				height: auto !important;
				min-height: 385px !important;
				max-height: none !important;
			}
			
			/* 시스템 리소스 영역의 accordion이 접혔을 때 그래프(canvas) 완전히 숨기기 */
			#chart-body .bg-content .accordion.collapsed {
				display: none !important;
				opacity: 0;
				max-height: 0 !important;
				height: 0 !important;
				overflow: hidden;
				margin: 0 !important;
				padding: 0 !important;
				transition: opacity 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
				pointer-events: none;
			}
			
			/* 시스템 리소스 영역의 accordion이 펼쳐졌을 때 그래프(canvas) 표시 */
			#chart-body .bg-content .accordion:not(.collapsed) {
				opacity: 1;
				max-height: 1000px;
				transition: opacity 0.3s ease, max-height 0.3s ease, margin 0.3s ease, padding 0.3s ease;
				pointer-events: auto;
			}
			
			/* 프로그래스 바 영역은 항상 표시 - 접혔을 때 위로 올라가도록 */
			#chart-body .bg-content .accordion ~ div {
				opacity: 1;
				display: block;
			}
			
			/* 시스템 리소스 영역 접혔을 때 프로그레스 바 영역이 위로 올라가도록 */
			#chart-body .bg-content.collapsed .accordion ~ div {
				margin-top: 0 !important;
			}
			
			/* GridStack 스타일 */
			.grid-stack {
				background: transparent;
				margin-top:-20px !important;
				margin-left:-20px !important;
				margin-bottom: 20px !important;
			}
			
			.grid-stack-item {
				background: transparent;
				padding:8px 8px !important;
				margin-bottom: 20px !important;
			}
			
			.grid-stack-item-content {
				background: var(--bg-content);
				border: var(--border-content);
				overflow: visible;
			}
			
			.grid-stack-item-removing {
				opacity: 0.8;
			}
			
			.grid-stack-item.ui-draggable-dragging {
				z-index: 1000;
				opacity: 0.8;
			}
			
			.grid-stack-item.ui-resizable-resizing {
				z-index: 1000;
			}
			
			/* 크기 조절 핸들 완전히 숨기기 */
			.grid-stack-item .ui-resizable-handle {
				display: none !important;
				visibility: hidden !important;
				opacity: 0 !important;
				pointer-events: none !important;
			}
			
			.grid-stack-item .ui-resizable-se {
				display: none !important;
				visibility: hidden !important;
				opacity: 0 !important;
				pointer-events: none !important;
			}
			
			/* 모든 크기 조절 핸들 숨기기 */
			.grid-stack-item .ui-resizable-n,
			.grid-stack-item .ui-resizable-s,
			.grid-stack-item .ui-resizable-e,
			.grid-stack-item .ui-resizable-w,
			.grid-stack-item .ui-resizable-ne,
			.grid-stack-item .ui-resizable-nw,
			.grid-stack-item .ui-resizable-sw {
				display: none !important;
				visibility: hidden !important;
				opacity: 0 !important;
				pointer-events: none !important;
			}
			
			/* 호버 시에도 크기 조절 핸들 숨기기 */
			.grid-stack-item:hover .ui-resizable-handle,
			.grid-stack-item:hover .ui-resizable-se,
			.grid-stack-item:hover .ui-resizable-n,
			.grid-stack-item:hover .ui-resizable-s,
			.grid-stack-item:hover .ui-resizable-e,
			.grid-stack-item:hover .ui-resizable-w,
			.grid-stack-item:hover .ui-resizable-ne,
			.grid-stack-item:hover .ui-resizable-nw,
			.grid-stack-item:hover .ui-resizable-sw {
				display: none !important;
				visibility: hidden !important;
				opacity: 0 !important;
				pointer-events: none !important;
			}
			
			/* 크기 조절 관련 모든 요소 숨기기 */
			.grid-stack-item *[class*="resizable"],
			.grid-stack-item *[class*="resize"] {
				display: none !important;
				visibility: hidden !important;
				opacity: 0 !important;
				pointer-events: none !important;
			}
			
			/* 드래그 중일 때 시각적 피드백 */
			.grid-stack-item.ui-draggable-dragging .dashbox {
				box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
				transform: rotate(2deg);
			}
			
			/* Accordion 토글 아이콘 스타일 */
			.accordion-toggle-icon {
				position: absolute !important;
				top: 10px !important;
				right: 10px !important;
				width: 20px !important;
				height: 20px !important;
				cursor: pointer !important;
				z-index: 1000 !important;
				pointer-events: auto !important;
				background: rgba(0, 0, 0, 0.1) !important;
				border-radius: 3px !important;
				display: flex !important;
				align-items: center !important;
				justify-content: center !important;
				transition: background-color 0.2s ease !important;
			}
			
			.accordion-toggle-icon:hover {
				background: rgba(0, 0, 0, 0.2) !important;
			}
			
			.accordion-toggle-icon i {
				color: rgba(255, 255, 255, 0.6) !important;
				font-size: 12px !important;
				transition: color 0.2s ease !important;
			}
			
			.accordion-toggle-icon:hover i {
				color: rgba(255, 255, 255, 0.9) !important;
			}
			
			/* GridStack 드래그 핸들과 accordion 아이콘 충돌 방지 */
			.grid-stack-item .dashbox {
				position: relative !important;
			}
			
			.grid-stack-item .dashbox .accordion-toggle-icon {
				pointer-events: auto !important;
				z-index: 1001 !important;
			}
			
			/* 드래그 중일 때도 accordion 아이콘은 클릭 가능하도록 */
			.grid-stack-item.ui-draggable-dragging .accordion-toggle-icon {
				pointer-events: auto !important;
				z-index: 1002 !important;
			}
		</style>
	</head>
	<body class="bgcolor06">
		<div class="wrap">			
			<!--Top Head 시작-->
			<div class="top-head">
				<div class="top-left">
					<div class="logo"><a href="subpage-html.html"><img src="images/logo-sse.svg"></a></div>
					<div class="position-absolute top-50 start-0 translate-middle" style="margin-left:480px;">
						<button class="btn btn-state">MINOR <span class="fw-bold badge bgc-gray"> 0</span></button>
						<button class="btn btn-state">MAJOR <span class="fw-bold badge bgc-gray"> 3</span></button>
						<button class="btn btn-state">CRITICAL <span class="fw-bold badge bgc-red"> 0</span></button>
					</div>
				</div>
				<div class="top-right position-absolute top-50 end-0 translate-middle-y">
					<div class="input-group btn-time mr10">
						<span class="form-control">00:31</span>
						<button class="btn btn-outline-secondary" type="button">Refresh</button>
					</div>
					<select class="mr10" style="width:100px;">
						  <option selected>admin</option>
						  <option value="1">나의 정보</option>
						  <option value="2">로그 아웃</option>
					</select>
					<ul>
						<li><i class="fa-solid fa-arrows-up-to-line head-icon" id="toggleAllDashbox" title="전체 접기/펴기"></i></li>
						<li><i class="fa-solid fa-table-cells head-icon" id="toggleAllFrontBack" title="전체 Front/Back 전환"></i></li>
						<li><i class="fa-solid fa-floppy-disk head-icon" id="saveStateIcon" title="현재 화면 상태 저장"></i></li>
						<li><i class="fa-solid fa-arrow-rotate-left head-icon" id="resetLayoutIcon" title="화면 레이아웃 초기화"></i></li>
						<li><i class="fa-solid fa-print head-icon"></i></li>
						<li><i class="fa-solid fa-gear head-icon" id="setcolorbtn"></i></li>
					</ul>
				</div>
				<div id="setcolor" style="display:none;">
					<table>
						<tr>
							<td class="w40p">검색조건</td>
							<td>
								<select>
									<option value="">---통계주기---</option>
									<option value="1시간">최근 1시간</option>
									<option value="1시간">최근 24시간</option>
									<option value="1시간">최근 7일</option>
									<option value="1시간">최근 30일</option>
								</select>
							</td>
						</tr>
						<tr>
							<td class="w40p">갱신주기</td>
							<td>
								<select id="refreshInterval">
									<option value="">---갱신주기---</option>
									<option value="1시간">1시간</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>세션 타임아웃</td>
							<td>
								<select id="sessionTimeout">
									<option value="">---세션 타임아웃---</option>
									<option value="30분">30분</option>
								</select>
							</td>
						</tr>
						<tr>
							<td>컬러테마</td>
							<td class="bgcolor">
								<button class="bgcolor01" id="bgcolor01"></button>
								<button class="bgcolor02" id="bgcolor02"></button>
								<button class="bgcolor03" id="bgcolor03"></button>
								<button class="bgcolor04" id="bgcolor04"></button>
								<button class="bgcolor05" id="bgcolor05"></button>
								<button class="bgcolor06" id="bgcolor06"></button>
								<button class="bgcolor07" id="bgcolor07"></button>
								<button class="bgcolor08" id="bgcolor08"></button>
								<button class="bgcolor09" id="bgcolor09"></button>
							</td>
						</tr>
						<tr style="border-bottom:0;">
							<td>기타 설정</td>
							<td>
								<label class="toggle_switch">
									<input type="checkbox" id="otherSettings">
									<span class="slider"></span>
								</label>
							</td>
						</tr>
					</table>
				</div>
			</div>
			<!--Top 끝-->
			
			<!--Left Menu 시작-->
			<div id="main" class="leftmenu">
				<div class="leftmenu-body">
					<div class="slide-btn"><i class="fa-solid fa-caret-right"></i></div>
					<div id="leftmenu" class="accordion">
						<div>
							<div class="menu-m on">
								<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#smenu1" aria-expanded="true" aria-controls="smenu1">
								<i class="fa-solid fa-database"></i> 정보
								</button>
							</div>
							<div id="smenu1" class="accordion-collapse collapse show menu-s" data-bs-parent="#leftmenu">
								<ul>
									<li class="on">일반</li>
									<li>통계</li>
									<li>실시간로그</li>
									<li>하드웨어</li>
								</ul>
							</div>
						</div>	
						<div>	
							<div class="menu-m">
								<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#smenu2" aria-expanded="false" aria-controls="smenu2">
								<i class="fa-solid fa-magnifying-glass-chart"></i> 분석
								</button>
							</div>
							<div id="smenu2" class="accordion-collapse collapse menu-s" data-bs-parent="#leftmenu">
								<ul>
									<li>클러스터링 트래픽 통계</li>
									<li>클러스터링 로그 검색</li>
									<li>트래픽 통계</li>
									<li>로그 검색</li>
									<li>리포트</li>
								 </ul>
							</div>
						</div>
						<div>
							<div class="menu-m">
								<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#smenu3" aria-expanded="false" aria-controls="smenu3">
								<i class="fa-solid fa-clipboard-check"></i> 정책
								</button>
							</div>
							<div id="smenu3" class="accordion-collapse collapse menu-s" data-bs-parent="#leftmenu">
								<ul>
									<li>클러스터링 트래픽 통계</li>
									<li>클러스터링 로그 검색</li>
									<li>트래픽 통계</li>
									<li>로그 검색</li>
									<li>리포트</li>
								 </ul>
							</div>
						</div>	
						<div>
							<div class="menu-m">
								<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#smenu4" aria-expanded="false" aria-controls="smenu4">
								<i class="fa-solid fa-eye"></i> 복호화
								</button>
							</div>
							<div id="smenu4" class="accordion-collapse collapse menu-s" data-bs-parent="#leftmenu">
								<ul>
									<li>복호화 제어</li>
									<li>미러링 설정</li>
									<li>인증서 관리</li>
									<li>서버 복호화</li>
								 </ul>
							</div>
						</div>	
						<div>
							<div class="menu-m">
								<button class="accordion-button" type="button" data-bs-toggle="collapse" data-bs-target="#smenu5" aria-expanded="false" aria-controls="smenu5">
								<i class="fa-solid fa-gear"></i> 설정
								</button>
							</div>
							<div id="smenu5" class="accordion-collapse collapse menu-s" data-bs-parent="#leftmenu">
								<ul>
									<li>네트워크</li>
									<li>라이선스</li>
									<li>시스템 관리</li>
									<li>바이패스</li>
									<li>업데이트/DB</li>
									<li>기타 설정</li>
									<li>재시작 / 종료</li>
								 </ul>
							</div>
						</div>

					</div>				
				</div>
			</div>
			<!--Left Menu 끝-->

			<!-- body 시작 -->
			<div class="container">
				<div class="d-flex justify-content-start">
					<!--좌측 그래프 시작-->
					<div class="w-system-resource mr10">
						<div id="chart-body" class="chart-bar">
							<div class="vstack g10">	
								<div class="bg-content active dashbox">
									<div class="dash-title">시스템 리소스</div>
									<div class="accordion">
										<div>
											<canvas id="systemResourceChart"></canvas>
										</div>
									</div>
									<div>
										<div class="fc-gray mt20">CPU</div>
										<div class="chart-data">
											<p class="fs200 fw700">89<span class="fw400"> %</span></p>
										</div>
										<div class="progress">
											<div class="progress-bar" style="width:85%;"></div>
										</div>
										
										<div class="fc-gray mt20">MEM</div>
										<div class="chart-data">
											<p class="fs200 fw700">5.88G <span class="fw400">/ 7.61G</span></p>
										</div>
										<div class="progress">
											<div class="progress-bar" style="width:25%;"></div>
										</div>
										
										<div class="fc-gray mt20">Hard Disk</div>
										<div class="chart-data">
											<p class="fs200 fw700">0<span class="fw400">/ 0</span></p>
										</div>
										<div class="progress">
											<div class="progress-bar" style="width:25%;"></div>
										</div>
									</div>
								</div>
							</div>
						</div>	
					</div>
					<!--좌측 그래프 끝-->

					<!--우측 데이터 시작-->
					<div class="w-main-content">
						<div id="dashboard-grid" class="grid-stack">
							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="0" gs-y="0">
								<div class="grid-stack-item-content bg-content active dashbox">
									<div class="dash-title">사용자 접속 현황</div>
									<div class="dash-table-box">
										<table class="demotable ml10 mr10">
											<tr>
												<td rowspan="2" class="demofont" style="width:60%">1500</td>
												<td class="fc-gray filter-option" data-filter="success" style="width:18%; cursor: pointer;" title="클릭하여 필터링">접속자 수</td>
												<td class="right pr10"  style="width:18%">1,000</td>
											</tr>
											<tr>
												<td class="fc-gray filter-option" data-filter="blocked" style="cursor: pointer;" title="클릭하여 필터링">접속차단 수</td>
												<td class="right pr10">500</td>
											</tr>
										</table>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="d-flex dash-graph-box">
												<div class="doughnut-chart-container">
													<canvas id="iamTrafficDoughnutChart"></canvas>
												</div>
												<div class="line-chart-container">
													<canvas id="iamTrafficChart"></canvas>
												</div>
											</div>
										</div>
										<div class="back">
											<table class="table" id="userAccessTable">
												<thead>
													<tr>
														<th stlye="width:35%;">시간</th>
														<th stlye="width:35%;">IP</th>
														<th stlye="width:25%;">User</th>
														<th stlye="width:5%;">접속 결과</th>
													</tr>
												</thead>
												<tbody>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>박영재</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김영아</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김혜인</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김정은</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>이관재</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김정은</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>이관재</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
												</tbody>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p>일반적인 접속량</p>
										<p class="fc-gray">시스템이 안정적으로 동작하고 있습니다.</p>
									</div>
								</div>
							</div>

							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="3" gs-y="0">
								<div class="grid-stack-item-content bg-content active dashbox error">
									<div class="dash-title">VPN 외부접속자 현황 <span class="error">확인필요</span></div>
									<div class="dash-table-box">
										<table class="demotable ml10 mr10">
											<tr>
												<td rowspan="2" class="demofont" style="width:60%">1,121</td>
												<td class="fc-gray filter-option" data-filter="success" style="width:18%; cursor: pointer;" title="클릭하여 필터링">접속자 수</td>
												<td class="right pr10"  style="width:18%">1,123</td>
											</tr>
											<tr>
												<td class="fc-gray filter-option" data-filter="blocked" style="cursor: pointer;" title="클릭하여 필터링">접속차단 수</td>
												<td class="right pr10">121</td>
											</tr>
										</table>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="d-flex dash-graph-box">
												<div class="doughnut-chart-container">
													<canvas id="ztnaTrafficDoughnutChart"></canvas>
												</div>
												<div class="line-chart-container">
													<canvas id="ztnaTrafficChart"></canvas>
												</div>
											</div>
										</div>
										<div class="back">
											<table class="table" id="vpnAccessTable">
												<thead>
													<tr>
														<th stlye="width:35%;">시간</th>
														<th stlye="width:35%;">IP</th>
														<th stlye="width:25%;">User</th>
														<th stlye="width:5%;">접속 결과</th>
													</tr>
												</thead>
												<tbody>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>박영재</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김영아</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김혜인</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김정은</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>이관재</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>김정은</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>212.222.333.123</td>
														<td>이관재</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
												</tbody>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p class="fc-red fw700">차단 건수 급증</p>
										<p class="fc-red">외부 접속 차단이 급증하고 있습니다. 확인이 필요합니다.</p>
									</div>
								</div>
							</div>

							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="6" gs-y="0">
								
								<div class="grid-stack-item-content bg-content active dashbox">
									<div class="dash-title">사이트 접속 현황</div>
									<div class="dash-table-box">
										<table class="demotable ml10 mr10">
											<tr>
												<td rowspan="2" class="demofont" style="width:60%">1,345</td>
												<td class="fc-gray filter-option" data-filter="success" style="width:18%; cursor: pointer;" title="클릭하여 필터링">허용 수</td>
												<td class="right pr10"  style="width:18%">1,222</td>
											</tr>
											<tr>
												<td class="fc-gray filter-option" data-filter="blocked" style="cursor: pointer;" title="클릭하여 필터링">차단 수</td>
												<td class="right pr10">123</td>
											</tr>
										</table>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="d-flex dash-graph-box">
												<canvas id="siteAccessChart"></canvas>
											</div>
										</div>
										<div class="back">
											<table class="table" id="siteAccessTable">
												<thead>
													<tr>
														<th stlye="width:35%;">시간</th>
														<th stlye="width:35%;">URL</th>
														<th stlye="width:25%;">구분</th>
														<th stlye="width:5%;">결과</th>
													</tr>
												</thead>
												<tbody>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>www.example.com</td>
														<td>WEB</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>www.blocked.com</td>
														<td>WEB</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 09:55:00</td>
														<td>www.allowed.com</td>
														<td>WEB</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 09:50:00</td>
														<td>www.malicious.com</td>
														<td>APP</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 09:45:00</td>
														<td>www.safe.com</td>
														<td>APP</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 09:40:00</td>
														<td>www.danger.com</td>
														<td>WEB</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 09:35:00</td>
														<td>www.trusted.com</td>
														<td>APP</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
												</tbody>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p>사이트 접속 동작 중</p>
										<p class="fc-gray">사이트 접속 건수가 일반적인 수치입니다.</p>
									</div>
								</div>
							</div>

							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="9" gs-y="0">
								<div class="grid-stack-item-content bg-content active dashbox">		
									<div class="dash-title">정보유출 차단 현황</div>
									<div class="dash-table-box">
										<table class="demotable ml10 mr10">
											<tr>
												<td rowspan="2" class="demofont" style="width:60%">1,983</td>
												<td class="fc-gray filter-option" data-filter="success" style="width:18%; cursor: pointer;" title="클릭하여 필터링">허용 수</td>
												<td class="right pr10"  style="width:18%">1,543</td>
											</tr>
											<tr>
												<td class="fc-gray filter-option" data-filter="blocked" style="cursor: pointer;" title="클릭하여 필터링">차단 수</td>
												<td class="right pr10">440</td>
											</tr>
										</table>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="d-flex dash-graph-box">
												<canvas id="infoLeakChart"></canvas>
											</div>
										</div>
										<div class="back">
											<table class="table" id="infoLeakTable">
												<thead>
													<tr>
														<th stlye="width:35%;">시간</th>
														<th stlye="width:20%;">부서</th>
														<th stlye="width:20%;">사용자명</th>
														<th stlye="width:25%;">서비스</th>
														<th stlye="width:5%;">결과</th>
													</tr>
												</thead>
												<tbody>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>DLP팀</td>
														<td>김영수</td>
														<td>웹메일</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>경영지원팀</td>
														<td>김영수</td>
														<td>SNS</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>DLP팀</td>
														<td>박수아</td>
														<td>업무공유</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>WAAP팀</td>
														<td>김영수</td>
														<td>웹메일</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>사업기획팀</td>
														<td>김영수</td>
														<td>메신저</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
													<tr data-status="blocked">
														<td>2025-10-17 10:00:00</td>
														<td>DLP팀</td>
														<td>김영수</td>
														<td>웹메일</td>
														<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
													</tr>
													<tr data-status="success">
														<td>2025-10-17 10:00:00</td>
														<td>DLP팀</td>
														<td>김영수</td>
														<td>웹메일</td>
														<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
													</tr>
												</tbody>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p>정보유출 차단 중</p>
										<p class="fc-gray">정보유출 차단이 정상적으로 동작하고 있습니다.</p>
									</div>
								</div>	
							</div>
							
							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="0" gs-y="2">
								<div class="grid-stack-item-content bg-content active dashbox ">
									<div class="dash-title">서비스별 접속 현황</div>
									<div class="dash-table-box">
										<table class="demotable ml10 mr10">
											<tr>
												<td rowspan="3" class="demofont" style="width:60%">10,234</td>
												<td class="fc-gray" style="width:18%">프로토콜</td>
												<td class="right pr10"  style="width:18%">1,245</td>
											</tr>
											<tr>
												<td class="fc-gray">웹메일</td>
												<td class="right pr10">596</td>
											</tr>
											<tr>
												<td class="fc-gray">매신저</td>
												<td class="right pr10">390</td>
											</tr>
										</table>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="dash-graph-box">
												<canvas id="aiTotalUsageChart"></canvas>
											</div>
										</div>
										<div class="back">
											<table class="table">
												<thead>
													<tr>
														<th style="width:60%">서비스</th>
														<th style="width:40%">접속 수</th>
													</tr>
												</thead>
												<tr>
													<td>프로토콜</td>
													<td>1,234</td>
												</tr>
												<tr>
													<td>웹메일</td>
													<td>5,018</td>
												</tr>
												<tr>
													<td>메신저</td>
													<td>4,908</td>
												</tr>
												<tr>
													<td>SNS</td>
													<td>1,234</td>
												</tr>
												<tr>
													<td>댓글</td>
													<td>1,234</td>
												</tr>
												<tr>
													<td>업무공유</td>
													<td>1,234</td>
												</tr>
												<tr>
													<td>FTP</td>
													<td>234</td>
												</tr>
												<tr>
													<td>WEB (POST)</td>
													<td>34</td>
												</tr>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p class="fc-red fw700">FTP 접속량 급증</p>
										<p>FTP 접속량이 급증하였습니다. 내부 이용자 확인이 필요합니다.</p>
									</div>
								</div>
							</div>
							
							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="3" gs-y="2">	
								<div class="grid-stack-item-content bg-content active dashbox">
									<div class="dash-title">정보 유출 감시 현황</div>
									<div class="dash-table-box mr10">
										<table class="demotable ml10 mr10">
											<tr>
												<td rowspan="3" class="demofont" style="width:60%">1,034</td>
												<td class="fc-gray" style="width:20%">전체</td>
												<td class="right"  style="width:20%">1,034</td>
											</tr>
											<tr>
												<td class="fc-gray">개인정보</td>
												<td class="right">1,000</td>
											</tr>
											<tr>
												<td class="fc-gray">키워드</td>
												<td class="right">34</td>
											</tr>
										</table>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="dash-graph-box">
												<canvas id="casbBlockChart"></canvas>
											</div>
										</div>
										<div class="back">
											<table class="table mt-2">
												<thead>
													<tr>
														<th style="width:35%;">시간</th>
														<th style="width:15%;">부서</th>
														<th style="width:15%;">사용자명</th>
														<th>개인정보</th>
														<th>키워드</th>
														<th>상태</th>
													</tr>
												</thead>
												<tr>
													<td>2025-10-17 10:00:00</td>
													<td>DLP팀</td>
													<td>김수아</td>
													<td>0</td>
													<td>12</td>
													<td class="center"><i class="fa-solid fa-eye fc-blue"></i></td>
												</tr>
												<tr>
													<td>2025-10-17 10:00:00</td>
													<td>DLP팀</td>
													<td>김수아</td>
													<td>234</td>
													<td>1</td>
													<td class="center"><i class="fa-solid fa-eye fc-blue"></i></td>
												</tr>
												<tr>
													<td>2025-10-17 10:00:00</td>
													<td>DLP팀</td>
													<td>김수아</td>
													<td>0</td>
													<td>12</td>
													<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
												</tr>
												<tr>
													<td>2025-10-17 10:00:00</td>
													<td>DLP팀</td>
													<td>김수아</td>
													<td>10</td>
													<td>72</td>
													<td class="center"><i class="fa-solid fa-circle-xmark fc-red"></i></td>
												</tr>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p>정보 유출 감시 중</p>
										<p class="fc-gray">정보유출이 의심되지 않습니다.</p>
									</div>
								</div>
							</div>	

							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="6" gs-y="2">
								<div class="grid-stack-item-content bg-content active dashbox">
									<div class="dash-title">시스템 트래픽 현황</div>
									<div class="dash-table-box">
										<table class="demotable ml10 mr10">
											<tr>
												<td rowspan="3" class="" style="width:60%"><span class="demofont">IN</span> <span class="demofont off">OUT</span></td>
												<td class="fc-gray" style="width:18%">SWG</td>
												<td class="right pr10"  style="width:18%">1,943</td>
											</tr>
											<tr>
												<td class="fc-gray">VPN</td>
												<td class="right pr10">1,943</td>
											</tr>
											<tr>
												<td class="fc-gray">DLP</td>
												<td class="right pr10">112</td>
											</tr>
										</table>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="dash-graph-box">
												<canvas id="ztnaBlockChart"></canvas>
											</div>
										</div>
										<div class="back">
											<table class="table mt-2">
												<thead>
													<tr>
														<th>시스템</th>
														<th>감시 건수</th>
														<th>차단 건수</th>
														<th>상태</th>
													</tr>
												</thead>
												<tr>
													<td>전체</td>
													<td>1,943</td>
													<td>0</td>
													<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
												</tr>
												<tr>
													<td>감시</td>
													<td>1,943</td>
													<td>0</td>
													<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
												</tr>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p>시스템 정상 동작 중</p>
										<p class="fc-gray">시스템이 모두 안정적으로 운영되고 있습니다.</p>
									</div>
								</div>
							</div>	

							<div class="grid-stack-item" gs-w="3" gs-h="2" gs-x="9" gs-y="2">
								<div class="grid-stack-item-content bg-content active dashbox">
									<div class="dash-title">정보유출감시 상세현황</div>
									<!-- 아코디언 밖에 항상 보이는 첫 번째와 두 번째 박스 -->
									<div class="info-leak-detail-top-container">
										<div class="info-leak-detail-box c-box">
											<span style="padding-right:30px;">멀웨어 탐지 </span>
											<p class="fs150 fw700">GOOD</p>
											<i class="fa-solid fa-face-smile fs200 pl10 fc-green"></i>
											<!--
											<p class="fs150 fw700">BAD</p>
											<i class="fa-solid fa-face-frown"></i>
											-->
										</div>
									</div>
									<div class="accordion">
										<div class="front">
											<div class="info-leak-detail-front-container">
												<div class="info-leak-detail-box c-box">
													<i class="fa-solid fa-square-envelope"></i>
													<span>메일</span>
													<p class="fs150 fw700">2,278</p>
												</div>
												<div class="info-leak-detail-box c-box">
													<i class="fa-solid fa-comments"></i>
													<span>메신저</span>
													<p class="fs150 fw700">1,212</p>
												</div>
												<div class="info-leak-detail-box c-box">
													<i class="fa-brands fa-square-instagram"></i>
													<span>SNS</span>
													<p class="fs150 fw700">278</p>
												</div>
												<div class="info-leak-detail-box c-box">
													<i class="fa-solid fa-square-share-nodes"></i>
													<span>업무공유</span>
													<p class="fs150 fw700">14</p>
												</div>
											</div>
										</div>
										<div class="back">
											<table class="table mt-2">
												<thead>
													<tr>
														<th>키워드</th>
														<th>빈도</th>
														<th>위험도</th>
														<th>상태</th>
													</tr>
												</thead>
												<tr>
													<td>주식추천</td>
													<td>45</td>
													<td>높음</td>
													<td class="center"><i class="fa-solid fa-circle-exclamation fc-red"></i></td>
												</tr>
												<tr>
													<td>AI추천주</td>
													<td>35</td>
													<td>높음</td>
													<td class="center"><i class="fa-solid fa-circle-exclamation fc-red"></i></td>
												</tr>
												<tr>
													<td>보고서</td>
													<td>50</td>
													<td>낮음</td>
													<td class="center"><i class="fa-solid fa-circle-check fc-green"></i></td>
												</tr>
											</table>
										</div>
									</div>
									<div class="dash-stitle">
										<p>멀웨어 탐지 동작 중</p>
										<p class="fc-gray">멀웨어 탐지가 정상적으로 동작하고 있습니다.</p>
									</div>
								</div>
							</div>			
						</div>
					</div>
					<!--우측 데이터 끝-->
				</div>

			</div>
			<!-- body 끝 -->
			<!--풋터 시작-->
			<div class="footer">
			ⓒ SOOSAN INT Co.,Ltd. eWalker SWG V10 10.0.1.23011201-2213715 <span class="fc-main"> DEMO-LICENSE 42 days left.</span>
			</div>
			<!--풋터 끝-->
		</div>
		
		<!-- Toast 알림 컨테이너 -->
		<div class="toast-container position-fixed top-0 end-0 p-3" style="z-index: 9999;">
			<div id="saveToast" class="toast" role="alert" aria-live="assertive" aria-atomic="true">
				<div class="toast-header">
					<i class="fa-solid fa-floppy-disk me-2"></i>
					<strong class="me-auto">저장 알림</strong>
					<button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="Close"></button>
				</div>
				<div class="toast-body" id="saveToastBody">
					저장 중...
				</div>
			</div>
		</div>
		
		<script>
			// JavaScript Document
			
			//===========================================
			//Toggle
			//===========================================
			$(function(){
				$('#setcolorbtn').click(function(){
					$("#setcolor").toggle();
				});
			});
			//===========================================
			//Color Theme
			//===========================================
			document.addEventListener('DOMContentLoaded', () => {
			    const body = document.body;
			
			    // 로컬 스토리지에서 저장된 테마 불러오기
			    const savedTheme = localStorage.getItem('selectedTheme');
			    
			    // 저장된 테마가 없으면 디폴트 설정 적용
			    if (savedTheme) {
			        applyTheme(savedTheme);
			    } else {
			        applyTheme('bgcolor04'); // 디폴트 설정
			    }
			
			    // 각 버튼에 이벤트 리스너 추가
			    for (let i = 1; i <= 9; i++) {
			        const button = document.getElementById(`bgcolor0${i}`);
			        button.addEventListener('click', () => {
			            const themeClass = `bgcolor0${i}`;
			            applyTheme(themeClass);
			            localStorage.setItem('selectedTheme', themeClass);
			        });
			    }
			
			    // 테마 적용 함수
			    function applyTheme(themeClass) {
			        const isLightTheme = ['bgcolor01', 'bgcolor02','bgcolor03'].includes(themeClass);
			        const themeMode = isLightTheme ? 'light' : 'dark';
			
			        body.className = themeClass;
			        body.setAttribute('data-bs-theme', themeMode);
			        
			        // 브라우저가 CSS를 다시 계산한 후 차트 재초기화
			        requestAnimationFrame(() => {
			            requestAnimationFrame(() => {
			                // 차트 재생성 (테마 변경 시 색상이 제대로 적용되도록)
			                if (typeof window.initCharts === 'function') {
			                    window.initCharts();
			                }
			            });
			        });
			    }
			});
			//===========================================
			//pw Button
			//===========================================
			$(document).ready(function(){
			    $('.form-password i').on('click',function(){
			        $('input').toggleClass('active');
			        if($('input').hasClass('active')){
			            $(this).attr('class',"fa-solid fa-eye on lg")
			            .prev('input').attr('type',"text");
			        }else{
			            $(this).attr('class',"fa-regular fa-eye-slash lg")
			            .prev('input').attr('type','password');
			        }
			    });
			});
			
			
			
			$(function () {
			  $('[data-toggle="tooltip"]').tooltip()
			})
			
			//===========================================
			//Time Display
			//===========================================
			$(document).ready(function(){
			    // 현재 시간을 09로 설정하고 시간표시 업데이트
			    function updateTimeDisplay() {
			        const now = new Date();
			        // 현재 시간을 09시로 설정 (분은 실제 분 사용)
			        const currentHour = 9;
			        const currentMinute = now.getMinutes();
			        
			        // 시간을 09:XX 형식으로 표시
			        const timeString = `${currentHour.toString().padStart(2, '0')}:${currentMinute.toString().padStart(2, '0')}`;
			        
			        // 모든 시간표시 요소 업데이트
			        $('.btn-time .form-control').text(timeString);
			    }
			    
			    // 페이지 로드 시 시간표시 업데이트
			    updateTimeDisplay();
			    
			    // 1분마다 시간표시 업데이트
			    setInterval(updateTimeDisplay, 60000);
			    
			    // Refresh 버튼 클릭 시 시간표시 업데이트
			    $('.btn-time button').on('click', function() {
			        updateTimeDisplay();
			    });
			});
			
			// Graph Sample JS
			// DOM이 완전히 로드된 후 실행
			document.addEventListener('DOMContentLoaded', function() {
				console.log('DOM loaded, initializing charts...');
				
				// 실시간 시간 업데이트
				function updateTime() {
					const now = new Date();
					const hours = now.getHours().toString().padStart(2, '0');
					const minutes = now.getMinutes().toString().padStart(2, '0');
					const timeElement = document.getElementById('currentTime');
					if (timeElement) {
						timeElement.textContent = hours + ':' + minutes;
					}
				}
				
				// 페이지 로드 시 시간 설정 및 1분마다 업데이트
				updateTime();
				setInterval(updateTime, 60000); // 1분마다 업데이트
				
			});
			
			// GridStack 초기화
			let grid;
			
			// 전체 dashbox 접기/펴기 기능
			let allDashboxCollapsed = false;
			
			// 아이콘 업데이트 함수
			function updateToggleIcon() {
				const toggleAllBtn = document.getElementById('toggleAllDashbox');
				if (toggleAllBtn) {
					if (allDashboxCollapsed) {
						// 접혀있을 때: 펴기 아이콘
						toggleAllBtn.className = 'fa-solid fa-arrows-down-to-line head-icon';
					} else {
						// 펼쳐져 있을 때: 접기 아이콘
						toggleAllBtn.className = 'fa-solid fa-arrows-up-to-line head-icon';
					}
				}
			}
			
			// 상태 저장 및 복원 기능
			const STATE_STORAGE_KEY = 'dashboard_state';
			
			// Toast 알림 표시 함수
			function showSaveNotification(message, isSuccess = true) {
				const toastElement = document.getElementById('saveToast');
				const toastBody = document.getElementById('saveToastBody');
				
				if (!toastElement || !toastBody) {
					// Toast가 없으면 alert 사용
					alert(message);
					return;
				}
				
				// 메시지 설정
				toastBody.textContent = message;
				
				// Toast 헤더 색상 변경
				const toastHeader = toastElement.querySelector('.toast-header');
				if (toastHeader) {
					// Bootstrap 클래스 제거하고 기본 클래스만 유지
					toastHeader.className = 'toast-header';
					if (isSuccess) {
						toastHeader.querySelector('i').className = 'fa-solid fa-check-circle me-2';
					} else {
						toastHeader.querySelector('i').className = 'fa-solid fa-exclamation-circle me-2';
					}
				}
				
				// Bootstrap Toast 인스턴스 생성 및 표시
				const toast = new bootstrap.Toast(toastElement, {
					autohide: true,
					delay: 3000
				});
				toast.show();
			}
			
			// 현재 화면 상태 저장 함수
			function saveDashboardState() {
				console.log('💾 저장 시작...');
				const state = {
					gridStack: [],
					leftBoxes: [],
					frontBack: {},
					accordion: {},
					allDashboxCollapsed: allDashboxCollapsed,
					timestamp: new Date().toISOString()
				};
				
				// title을 키로 사용하는 Map을 사용하여 중복 제거
				const gridStackMap = new Map();
				const leftBoxesSet = new Set();
				
				// 모든 dashbox 상태 저장 (GridStack 포함 및 왼쪽 시스템 현황 박스)
				const allDashboxes = document.querySelectorAll('.dashbox');
				allDashboxes.forEach(function(dashbox) {
					const title = dashbox.querySelector('.dash-title');
					const titleText = title ? title.textContent.trim() : '';
					
					if (!titleText) return;
					
					// GridStack 아이템인지 확인
					const gridItem = dashbox.closest('.grid-stack-item');
					if (gridItem && grid) {
						// GridStack 노드 찾기
						const nodes = grid.engine.nodes;
						for (let i = 0; i < nodes.length; i++) {
							const node = nodes[i];
							const nodeElement = node.el ? node.el[0] : null;
							if (nodeElement === gridItem) {
								// 같은 title이 있으면 덮어쓰기 (최신 상태 유지)
								gridStackMap.set(titleText, {
									title: titleText,
									x: node.x,
									y: node.y,
									w: node.w,
									h: node.h
								});
								break;
							}
						}
					} else {
						// 왼쪽 시스템 현황 박스 (GridStack에 포함되지 않음)
						const isLeftSystemBox = dashbox.closest('.chart-bar') !== null;
						if (isLeftSystemBox) {
							leftBoxesSet.add(titleText);
						}
					}
					
					// 프론트/백 상태 저장 (같은 title이 있으면 덮어쓰기)
					const accordion = dashbox.querySelector('.accordion');
					if (accordion) {
						const frontElement = accordion.querySelector('.front');
						const backElement = accordion.querySelector('.back');
						if (frontElement && backElement) {
							// toggleFrontBack 함수와 동일한 로직으로 상태 확인
							const isBackVisible = backElement.classList.contains('show') && 
												  backElement.style.visibility !== 'hidden' && 
												  backElement.style.opacity !== '0';
							state.frontBack[titleText] = isBackVisible;
						}
						
						// 아코디언 상태 저장 (같은 title이 있으면 덮어쓰기)
						const isCollapsed = accordion.classList.contains('collapsed');
						state.accordion[titleText] = isCollapsed;
					}
				});
				
				// Map과 Set을 배열로 변환
				state.gridStack = Array.from(gridStackMap.values());
				state.leftBoxes = Array.from(leftBoxesSet);
				
				// 설정 항목 저장
				const refreshInterval = document.getElementById('refreshInterval');
				const sessionTimeout = document.getElementById('sessionTimeout');
				const otherSettings = document.getElementById('otherSettings');
				
				if (refreshInterval) {
					state.settings = {
						refreshInterval: refreshInterval.value || '',
						sessionTimeout: sessionTimeout ? (sessionTimeout.value || '') : '',
						otherSettings: otherSettings ? otherSettings.checked : false
					};
				}
				
				// 저장 전 상태 요약 로그
				console.log('📊 저장할 상태 요약:', {
					gridStack: state.gridStack.length + '개',
					leftBoxes: state.leftBoxes.length + '개',
					frontBack: Object.keys(state.frontBack).length + '개',
					accordion: Object.keys(state.accordion).length + '개',
					allCollapsed: state.allDashboxCollapsed,
					settings: state.settings ? '저장됨' : '없음'
				});
				
				// 로컬 스토리지에 저장
				try {
					const stateString = JSON.stringify(state);
					console.log('💾 localStorage에 저장 시도 중... (크기: ' + (stateString.length / 1024).toFixed(2) + ' KB)');
					localStorage.setItem(STATE_STORAGE_KEY, stateString);
					
					// 저장이 실제로 성공했는지 확인 (검증)
					const savedState = localStorage.getItem(STATE_STORAGE_KEY);
					if (savedState && savedState === stateString) {
						console.log('✅ Dashboard state saved successfully');
						console.log('📊 Saved state:', {
							gridStackItems: state.gridStack.length,
							leftBoxes: state.leftBoxes.length,
							frontBackStates: Object.keys(state.frontBack).length,
							accordionStates: Object.keys(state.accordion).length,
							timestamp: state.timestamp,
							dataSize: (stateString.length / 1024).toFixed(2) + ' KB'
						});
						return true; // 저장 성공
					} else {
						console.error('❌ Dashboard state save verification failed');
						console.error('Expected:', stateString.substring(0, 100) + '...');
						console.error('Got:', savedState ? savedState.substring(0, 100) + '...' : 'null');
						return false; // 저장 실패
					}
				} catch (error) {
					console.error('Error saving dashboard state:', error);
					// localStorage 용량 초과 등의 에러 확인
					if (error.name === 'QuotaExceededError') {
						console.error('LocalStorage quota exceeded');
					}
					return false; // 저장 실패
				}
			}
			
			// 상태 복원 중복 실행 방지 플래그
			let isRestoring = false;
			
			// 저장 상태 확인 함수 (디버깅용) - 전역으로 노출
			window.checkSaveState = function() {
				const savedState = localStorage.getItem(STATE_STORAGE_KEY);
				if (savedState) {
					try {
						const state = JSON.parse(savedState);
						console.log('📋 현재 저장된 상태 정보:');
						console.log('  - GridStack 항목:', state.gridStack.length + '개');
						console.log('  - 왼쪽 박스:', state.leftBoxes.length + '개');
						console.log('  - Front/Back 상태:', Object.keys(state.frontBack).length + '개');
						console.log('  - Accordion 상태:', Object.keys(state.accordion).length + '개');
						console.log('  - 전체 접기 상태:', state.allDashboxCollapsed);
						console.log('  - 저장 시간:', new Date(state.timestamp).toLocaleString('ko-KR'));
						console.log('  - 데이터 크기:', (savedState.length / 1024).toFixed(2) + ' KB');
						console.log('  - 전체 상태:', state);
						return state;
					} catch (error) {
						console.error('❌ 저장된 상태 파싱 오류:', error);
						return null;
					}
				} else {
					console.log('📋 저장된 상태가 없습니다.');
					return null;
				}
			};
			
			// 저장된 화면 상태 복원 함수
			function restoreDashboardState() {
				// 이미 복원 중이면 실행하지 않음
				if (isRestoring) {
					return;
				}
				
				try {
					const savedState = localStorage.getItem(STATE_STORAGE_KEY);
					if (!savedState) {
						console.log('No saved state found');
						return;
					}
					
					isRestoring = true;
					const state = JSON.parse(savedState);
					console.log('Restoring dashboard state:', state);
					
					// 전체 dashbox 접기/펴기 상태 복원
					if (state.allDashboxCollapsed !== undefined) {
						allDashboxCollapsed = state.allDashboxCollapsed;
						// 아이콘 업데이트
						updateToggleIcon();
					}
					
					// 설정 항목 복원
					if (state.settings) {
						const refreshInterval = document.getElementById('refreshInterval');
						const sessionTimeout = document.getElementById('sessionTimeout');
						const otherSettings = document.getElementById('otherSettings');
						
						if (refreshInterval && state.settings.refreshInterval !== undefined) {
							refreshInterval.value = state.settings.refreshInterval;
						}
						if (sessionTimeout && state.settings.sessionTimeout !== undefined) {
							sessionTimeout.value = state.settings.sessionTimeout;
						}
						if (otherSettings && state.settings.otherSettings !== undefined) {
							otherSettings.checked = state.settings.otherSettings;
						}
					}
					
					// 모든 dashbox 상태 복원 함수
					function restoreDashboxState(dashbox, titleText) {
						// 프론트/백 상태 복원
						if (state.frontBack && state.frontBack[titleText] !== undefined) {
							const accordion = dashbox.querySelector('.accordion');
							if (accordion) {
								const frontElement = accordion.querySelector('.front');
								const backElement = accordion.querySelector('.back');
								if (frontElement && backElement) {
									if (state.frontBack[titleText]) {
										// back으로 전환
										frontElement.classList.add('hide');
										frontElement.style.position = 'absolute';
										frontElement.style.visibility = 'hidden';
										frontElement.style.opacity = '0';
										frontElement.style.pointerEvents = 'none';
										
										backElement.classList.add('show');
										backElement.style.visibility = 'visible';
										backElement.style.opacity = '1';
										backElement.style.pointerEvents = 'auto';
									} else {
										// front로 전환
										backElement.classList.remove('show');
										backElement.style.visibility = 'hidden';
										backElement.style.opacity = '0';
										backElement.style.pointerEvents = 'none';
										
										frontElement.classList.remove('hide');
										frontElement.style.position = 'relative';
										frontElement.style.visibility = 'visible';
										frontElement.style.opacity = '1';
										frontElement.style.pointerEvents = 'auto';
									}
								}
							}
						}
						
						// 아코디언 상태 복원
						if (state.accordion && state.accordion[titleText] !== undefined) {
							const accordion = dashbox.querySelector('.accordion');
							if (accordion) {
								const isLeftSystemBox = dashbox.closest('.chart-bar') !== null;
								const gridItem = dashbox.closest('.grid-stack-item');
								
								if (state.accordion[titleText]) {
									// 접힌 상태
									accordion.classList.add('collapsed');
									dashbox.classList.add('collapsed');
									
									// 높이 설정 (헬퍼 함수 사용)
									setDashboxHeight(dashbox, true);
									
									if (gridItem && grid && !isLeftSystemBox) {
										grid.update(gridItem, {h: 1});
										gridItem.classList.add('collapsed-height-1');
									}
									
									// 아이콘 업데이트
									const iconArea = dashbox.querySelector('.accordion-toggle-icon');
									if (iconArea) {
										const icon = iconArea.querySelector('i');
										if (icon) {
											icon.className = 'fa-solid fa-chevron-down';
										}
									}
								} else {
									// 펼친 상태
									accordion.classList.remove('collapsed');
									dashbox.classList.remove('collapsed');
									// 높이 설정 (헬퍼 함수 사용)
									setDashboxHeight(dashbox, false);
									
									if (gridItem && grid) {
										grid.update(gridItem, {h: 2});
										gridItem.classList.remove('collapsed-height-1');
									}
									
									// 아이콘 업데이트
									const iconArea = dashbox.querySelector('.accordion-toggle-icon');
									if (iconArea) {
										const icon = iconArea.querySelector('i');
										if (icon) {
											icon.className = 'fa-solid fa-chevron-up';
										}
									}
								}
							}
						}
					}
					
					// 복원 함수를 여러 단계로 나누어 실행
					function restoreGridStackPositions() {
						if (!grid || !state.gridStack || state.gridStack.length === 0) {
							return;
						}
						
						state.gridStack.forEach(function(itemState) {
							const gridItems = document.querySelectorAll('.grid-stack-item');
							gridItems.forEach(function(gridItem) {
								const dashbox = gridItem.querySelector('.dashbox');
								if (dashbox) {
									const title = dashbox.querySelector('.dash-title');
									const titleText = title ? title.textContent.trim() : '';
									
									if (titleText === itemState.title) {
										// 위치 업데이트
										grid.update(gridItem, {
											x: itemState.x,
											y: itemState.y,
											w: itemState.w,
											h: itemState.h
										});
										
										// 상태 복원
										restoreDashboxState(dashbox, titleText);
									}
								}
							});
						});
					}
					
					function restoreLeftBoxes() {
						if (!state.leftBoxes || state.leftBoxes.length === 0) {
							return;
						}
						
						state.leftBoxes.forEach(function(titleText) {
							const allDashboxes = document.querySelectorAll('.dashbox');
							allDashboxes.forEach(function(dashbox) {
								const isLeftSystemBox = dashbox.closest('.chart-bar') !== null;
								if (isLeftSystemBox) {
									const title = dashbox.querySelector('.dash-title');
									const dashboxTitleText = title ? title.textContent.trim() : '';
									if (dashboxTitleText === titleText) {
										restoreDashboxState(dashbox, titleText);
									}
								}
							});
						});
					}
					
					// 즉시 실행 (GridStack이 준비되었는지 확인)
					if (grid && state.gridStack && state.gridStack.length > 0) {
						restoreGridStackPositions();
					}
					
					// 왼쪽 시스템 현황 박스 상태 복원 (즉시 실행)
					if (state.leftBoxes && state.leftBoxes.length > 0) {
						restoreLeftBoxes();
					}
					
					// 모든 dashbox에 대해 상태 복원 (즉시 실행)
					const allDashboxes = document.querySelectorAll('.dashbox');
					allDashboxes.forEach(function(dashbox) {
						const title = dashbox.querySelector('.dash-title');
						const titleText = title ? title.textContent.trim() : '';
						if (titleText) {
							restoreDashboxState(dashbox, titleText);
						}
					});
					
					// GridStack 위치 복원 재시도 (GridStack이 아직 준비되지 않은 경우를 위해)
					if (grid && state.gridStack && state.gridStack.length > 0) {
						setTimeout(function() {
							restoreGridStackPositions();
							isRestoring = false;
						}, 100);
					} else {
						isRestoring = false;
					}
					
					console.log('Dashboard state restored successfully');
					
					// 상태 복원 후 아이콘 업데이트
					setTimeout(function() {
						updateFrontBackIcon();
					}, 150);
				} catch (error) {
					console.error('Error restoring dashboard state:', error);
					isRestoring = false;
				}
			}
			
			document.addEventListener('DOMContentLoaded', function() {
				// 먼저 accordion 기능 초기화
				initializeAccordionFeatures();
				
				// front/back 토글 기능 초기화
				initializeFrontBackToggle();
				
				// GridStack 초기화
				if (typeof GridStack !== 'undefined') {
				grid = GridStack.init({
					column: 12,
					cellHeight: 200,
					margin: 15,
					removable: false,
					acceptWidgets: false,
					draggable: {
						handle: '.dashbox',
						scroll: true
					},
					resizable: false,
					disableResize: true,
					disableOneColumnMode: true
				});
					
					console.log('GridStack initialized successfully');
					
					// GridStack 위치 변경 시 자동 저장
					grid.on('change', function(event, items) {
						// 디바운스 처리 (500ms)
						clearTimeout(window.gridStackSaveTimeout);
						window.gridStackSaveTimeout = setTimeout(function() {
							const saved = saveDashboardState();
							if (saved) {
								console.log('💾 자동 저장 완료 (GridStack 위치 변경)');
							} else {
								console.warn('⚠️ 자동 저장 실패 (GridStack 위치 변경)');
							}
						}, 500);
					});
					
					// 모든 그리드 아이템에 대해 크기 조절 비활성화
					grid.on('added', function(event, items) {
						items.forEach(function(item) {
							if (item.el) {
								// jQuery UI resizable 비활성화
								if (item.el.resizable) {
									item.el.resizable('disable');
								}
								// 크기 조절 핸들 제거
								item.el.find('.ui-resizable-handle').remove();
								
								// accordion 기능 보호
								protectAccordionInItem(item.el[0]);
							}
						});
					});
					
					// 기존 아이템들에 대해서도 크기 조절 비활성화
					grid.engine.nodes.forEach(function(node) {
						if (node.el) {
							// node.el이 jQuery 객체가 아닐 수 있으므로 jQuery로 감싸기
							const $el = node.el.jquery ? node.el : $(node.el);
							if ($el.resizable) {
								$el.resizable('disable');
							}
							$el.find('.ui-resizable-handle').remove();
							
							// accordion 기능 보호
							protectAccordionInItem($el[0]);
						}
					});
					
					// 저장된 상태 복원 (GridStack 초기화 완료 후 즉시 실행)
					restoreDashboardState();
				} else {
					console.error('GridStack library not loaded');
					// GridStack이 없어도 상태 복원은 시도
					restoreDashboardState();
				}
				
				// 저장 아이콘 클릭 이벤트
				const saveStateIcon = document.getElementById('saveStateIcon');
				if (saveStateIcon) {
					saveStateIcon.addEventListener('click', function() {
						// 저장 중 표시
						showSaveNotification('저장 중...', true);
						
						// 저장 실행
						const saved = saveDashboardState();
						
						// 결과 알림
						if (saved) {
							const savedState = localStorage.getItem(STATE_STORAGE_KEY);
							const state = savedState ? JSON.parse(savedState) : null;
							const itemCount = state ? (state.gridStack.length + state.leftBoxes.length) : 0;
							showSaveNotification(`현재 화면 상태가 저장되었습니다. (${itemCount}개 항목)`, true);
							
							// 저장 아이콘에 시각적 피드백 추가
							saveStateIcon.style.color = '#28a745';
							setTimeout(function() {
								saveStateIcon.style.color = '';
							}, 1000);
						} else {
							showSaveNotification('화면 상태 저장에 실패했습니다.\n브라우저의 저장 공간이 부족하거나 저장 기능이 제한되어 있을 수 있습니다.', false);
							
							// 저장 실패 시 시각적 피드백
							saveStateIcon.style.color = '#dc3545';
							setTimeout(function() {
								saveStateIcon.style.color = '';
							}, 1000);
						}
					});
				}
				
				// 레이아웃 초기화 아이콘 클릭 이벤트
				const resetLayoutIcon = document.getElementById('resetLayoutIcon');
				if (resetLayoutIcon) {
					resetLayoutIcon.addEventListener('click', function() {
						// 확인 메시지
						if (!confirm('화면 레이아웃을 초기 상태로 되돌리시겠습니까?\n모든 변경사항이 초기화됩니다.')) {
							return;
						}
						
						// 초기화 중 표시
						showSaveNotification('레이아웃 초기화 중...', true);
						
						// localStorage에서 저장된 상태 삭제
						localStorage.removeItem(STATE_STORAGE_KEY);
						
						// GridStack 아이템들을 원래 위치로 복원
						if (grid) {
							const gridItems = document.querySelectorAll('.grid-stack-item');
							gridItems.forEach(function(gridItem) {
								const x = parseInt(gridItem.getAttribute('gs-x')) || 0;
								const y = parseInt(gridItem.getAttribute('gs-y')) || 0;
								const w = parseInt(gridItem.getAttribute('gs-w')) || 3;
								const h = parseInt(gridItem.getAttribute('gs-h')) || 2;
								
								grid.update(gridItem, {
									x: x,
									y: y,
									w: w,
									h: h
								});
							});
						}
						
						// 모든 dashbox 상태를 초기 상태로 복원
						const allDashboxes = document.querySelectorAll('.dashbox');
						allDashboxes.forEach(function(dashbox) {
							// accordion 펼침
							const accordion = dashbox.querySelector('.accordion');
							if (accordion) {
								accordion.classList.remove('collapsed');
								dashbox.classList.remove('collapsed');
								// 높이 설정 (헬퍼 함수 사용)
								const isLeftSystemBox = dashbox.closest('.chart-bar') !== null;
								setDashboxHeight(dashbox, false);
								
								// GridStack 아이템 높이도 복원
								const gridItem = dashbox.closest('.grid-stack-item');
								if (gridItem && grid) {
									const h = parseInt(gridItem.getAttribute('gs-h')) || 2;
									grid.update(gridItem, {h: h});
									gridItem.classList.remove('collapsed-height-1');
								}
								
								// 아이콘 업데이트
								const iconArea = dashbox.querySelector('.accordion-toggle-icon');
								if (iconArea) {
									const icon = iconArea.querySelector('i');
									if (icon) {
										icon.className = 'fa-solid fa-chevron-up';
									}
								}
								
								// front/back 상태 초기화 (front로)
								const frontElement = accordion.querySelector('.front');
								const backElement = accordion.querySelector('.back');
								if (frontElement && backElement) {
									// front 표시
									frontElement.classList.remove('hide');
									frontElement.style.position = 'relative';
									frontElement.style.visibility = 'visible';
									frontElement.style.opacity = '1';
									frontElement.style.pointerEvents = 'auto';
									
									// back 숨김
									backElement.classList.remove('show');
									backElement.style.visibility = 'hidden';
									backElement.style.opacity = '0';
									backElement.style.pointerEvents = 'none';
								}
							}
						});
						
						// 전체 접기/펴기 상태 초기화
						allDashboxCollapsed = false;
						
						// 초기화 완료 알림
						showSaveNotification('화면 레이아웃이 초기 상태로 복원되었습니다.', true);
						
						// 초기화 아이콘에 시각적 피드백 추가
						resetLayoutIcon.style.color = '#28a745';
						setTimeout(function() {
							resetLayoutIcon.style.color = '';
						}, 1000);
					});
				}
			});
			
			// accordion 기능 초기화 함수
			function initializeAccordionFeatures() {
				// 전체 접기/펴기 버튼 이벤트
				const toggleAllBtn = document.getElementById('toggleAllDashbox');
				if (toggleAllBtn) {
					toggleAllBtn.addEventListener('click', function() {
						// 모든 dashbox 찾기
						const allDashboxes = document.querySelectorAll('.dashbox');
						allDashboxes.forEach(function(dashbox) {
							const accordion = dashbox.querySelector('.accordion');
							if (accordion) {
								// 왼쪽 시스템 현황 박스인지 확인 (chart-bar 클래스가 있는지 확인)
								const isLeftSystemBox = dashbox.closest('.chart-bar') !== null;
								
								if (allDashboxCollapsed) {
									// 현재 모두 접혀있으면 펴기
									accordion.classList.remove('collapsed');
									dashbox.classList.remove('collapsed');
									// 높이 설정 (헬퍼 함수 사용)
									setDashboxHeight(dashbox, false);
									
									// GridStack 아이템 높이도 업데이트
									const gridItem = dashbox.closest('.grid-stack-item');
									if (gridItem && grid) {
										grid.update(gridItem, {h: 2});
										gridItem.classList.remove('collapsed-height-1');
										
										// 높이 강제 설정 제거
										setTimeout(function() {
											if (gridItem) {
												gridItem.style.height = '';
												const content = gridItem.querySelector('.grid-stack-item-content');
												if (content) {
													content.style.height = '';
												}
											}
										}, 50);
									}
								} else {
								// 현재 펼쳐져 있으면 접기
								accordion.classList.add('collapsed');
								dashbox.classList.add('collapsed');
								
								// 높이 설정 (헬퍼 함수 사용)
								setDashboxHeight(dashbox, true);
								
								// GridStack 아이템 높이도 업데이트
									const gridItem = dashbox.closest('.grid-stack-item');
									if (gridItem && grid) {
										grid.update(gridItem, {h: 1});
										gridItem.classList.add('collapsed-height-1');
										
										// 185px로 강제 설정
										setTimeout(function() {
											if (gridItem) {
												gridItem.style.height = '185px';
												const content = gridItem.querySelector('.grid-stack-item-content');
												if (content) {
													content.style.height = '185px';
												}
											}
										}, 50);
									}
								}
							}
						});
						
						// 상태 반전
						allDashboxCollapsed = !allDashboxCollapsed;
						
						// 아이콘 업데이트
						updateToggleIcon();
						
						// 상태 자동 저장
						setTimeout(function() {
							const saved = saveDashboardState();
							if (saved) {
								console.log('💾 자동 저장 완료 (전체 접기/펴기)');
							}
						}, 100);
					});
				}
				
				// 전체 Front/Back 전환 버튼 이벤트
				const toggleAllFrontBackBtn = document.getElementById('toggleAllFrontBack');
				if (toggleAllFrontBackBtn) {
					toggleAllFrontBackBtn.addEventListener('click', function() {
						// 현재 아이콘 확인
						const isTableCells = this.classList.contains('fa-table-cells');
						const isChartColumn = this.classList.contains('fa-chart-column');
						
						// 모든 dashbox 찾기
						const allDashboxes = document.querySelectorAll('.dashbox');
						let hasFrontBack = false;
						
						allDashboxes.forEach(function(dashbox) {
							const accordion = dashbox.querySelector('.accordion');
							if (accordion) {
								const frontElement = accordion.querySelector('.front');
								const backElement = accordion.querySelector('.back');
								
								// front와 back이 모두 있는 경우에만 전환
								if (frontElement && backElement) {
									hasFrontBack = true;
									
									// fa-table-cells 아이콘 클릭 시 → 전체 back 보이게
									if (isTableCells) {
										// back으로 전환
										frontElement.classList.add('hide');
										frontElement.style.position = 'absolute';
										frontElement.style.top = '0';
										frontElement.style.left = '0';
										frontElement.style.width = '100%';
										frontElement.style.height = '100%';
										frontElement.style.visibility = 'hidden';
										frontElement.style.opacity = '0';
										frontElement.style.pointerEvents = 'none';
										frontElement.style.transform = 'translateY(-10px)';
										
										backElement.style.position = 'absolute';
										backElement.style.top = '0';
										backElement.style.left = '0';
										backElement.style.width = '100%';
										backElement.style.height = '100%';
										backElement.style.visibility = 'visible';
										backElement.style.pointerEvents = 'auto';
										backElement.style.transform = 'translateY(0)';
										
										setTimeout(() => {
											backElement.classList.add('show');
											backElement.style.opacity = '1';
										}, 10);
									}
									// fa-chart-column 아이콘 클릭 시 → 전체 front 보이게
									else if (isChartColumn) {
										// front로 전환
										backElement.classList.remove('show');
										backElement.style.visibility = 'hidden';
										backElement.style.opacity = '0';
										backElement.style.pointerEvents = 'none';
										
										frontElement.style.visibility = 'visible';
										frontElement.style.opacity = '1';
										frontElement.style.pointerEvents = 'auto';
										frontElement.classList.remove('hide');
										frontElement.style.position = 'relative';
										frontElement.style.transform = 'translateY(0)';
									}
								}
							}
						});
						
						if (!hasFrontBack) {
							console.log('Front/Back 전환이 가능한 dashbox가 없습니다.');
						} else {
							// 상태 자동 저장 및 아이콘 업데이트
							setTimeout(function() {
								const saved = saveDashboardState();
								if (saved) {
									console.log('💾 자동 저장 완료 (전체 Front/Back 전환)');
								}
								updateFrontBackIcon();
							}, 100);
						}
					});
				}
				
				// 모든 dashbox에 대해 이벤트 리스너 추가
				document.querySelectorAll('.dashbox').forEach(function(dashbox) {
					addAccordionToDashbox(dashbox);
				});
				
				// 초기 아이콘 업데이트
				updateToggleIcon();
				updateFrontBackIcon();
			}
			
			// 높이 설정 헬퍼 함수
			function setDashboxHeight(dashbox, isCollapsed) {
				const isLeftSystemBox = dashbox.closest('.chart-bar') !== null;
				const isSystemResource = dashbox.closest('#chart-body') !== null && dashbox.classList.contains('bg-content');
				
				// 시스템 리소스 영역은 CSS가 자동으로 높이를 관리하므로 인라인 스타일 제거
				if (isSystemResource) {
					// CSS가 자동으로 높이를 관리하므로 인라인 스타일 제거
					dashbox.style.minHeight = '';
					dashbox.style.height = '';
					// overflow만 설정
					if (isCollapsed) {
						dashbox.style.overflow = 'hidden';
					} else {
						dashbox.style.overflow = '';
					}
					return;
				}
				
				// 다른 영역은 기존 로직 유지
				if (isCollapsed) {
					// 접힌 상태: 오른쪽 박스는 185px
					dashbox.style.minHeight = '185px';
					dashbox.style.height = '185px';
					// bg-content overflow 설정
					if (dashbox.classList.contains('bg-content')) {
						dashbox.style.overflow = 'hidden';
					}
				} else {
					// 펼친 상태: 기본값
					dashbox.style.minHeight = '';
					dashbox.style.height = '';
					// bg-content overflow 초기화
					if (dashbox.classList.contains('bg-content')) {
						dashbox.style.overflow = '';
					}
				}
			}
			
			// 개별 dashbox에 accordion 기능 추가
			function addAccordionToDashbox(dashbox) {
				// dashbox 내부에 accordion이 있는지 확인
				const accordion = dashbox.querySelector('.accordion');
				if (accordion) {
					// 기존 아이콘이 있는지 확인하고 제거
					const existingIcon = dashbox.querySelector('.accordion-toggle-icon');
					if (existingIcon) {
						existingIcon.remove();
					}
					
					// 우측 상단 아이콘 영역에 별도 클릭 이벤트 추가
					const iconArea = document.createElement('div');
					iconArea.className = 'accordion-toggle-icon';
					iconArea.style.cssText = 'position: absolute; top: 10px; right: 10px; width: 20px; height: 20px; cursor: pointer; z-index: 1000; pointer-events: auto;';
					iconArea.innerHTML = '<i class="fa-solid fa-chevron-up" style="color: rgba(255,255,255,0.3);"></i>';
					
					// 아이콘 클릭 이벤트
					iconArea.addEventListener('click', function(e) {
						e.preventDefault();
						e.stopPropagation();
						e.stopImmediatePropagation();
						
						accordion.classList.toggle('collapsed');
						dashbox.classList.toggle('collapsed');
						
						// 높이 설정 (헬퍼 함수 사용)
						setDashboxHeight(dashbox, accordion.classList.contains('collapsed'));
						
							// GridStack 아이템 높이도 업데이트
							const gridItem = dashbox.closest('.grid-stack-item');
							if (gridItem && grid) {
								if (accordion.classList.contains('collapsed')) {
									// 접힌 상태: 높이를 1로 설정하고 CSS 클래스 추가
									grid.update(gridItem, {h: 1});
									gridItem.classList.add('collapsed-height-1');
									
									// 185px로 강제 설정
									setTimeout(function() {
										if (gridItem) {
											gridItem.style.height = '185px';
											const content = gridItem.querySelector('.grid-stack-item-content');
											if (content) {
												content.style.height = '185px';
											}
										}
									}, 50);
							} else {
								// 펼친 상태: 원래 높이로 복원
								grid.update(gridItem, {h: 2});
								gridItem.classList.remove('collapsed-height-1');
								
								// 높이 강제 설정 제거
								setTimeout(function() {
									if (gridItem) {
										gridItem.style.height = '';
										const content = gridItem.querySelector('.grid-stack-item-content');
										if (content) {
											content.style.height = '';
										}
									}
								}, 50);
							}
						}
						
						// 아이콘 방향 변경
						const icon = iconArea.querySelector('i');
						if (accordion.classList.contains('collapsed')) {
							icon.className = 'fa-solid fa-chevron-down';
						} else {
							icon.className = 'fa-solid fa-chevron-up';
						}
						
						// 상태 자동 저장
						setTimeout(function() {
							const saved = saveDashboardState();
							if (saved) {
								console.log('💾 자동 저장 완료 (전체 접기/펴기)');
							}
						}, 100);
					});
					
					// 마우스 이벤트도 방지
					iconArea.addEventListener('mousedown', function(e) {
						e.preventDefault();
						e.stopPropagation();
						e.stopImmediatePropagation();
					});
					
					dashbox.style.position = 'relative';
					dashbox.appendChild(iconArea);
				}
			}
			
			// GridStack 아이템에서 accordion 기능 보호
			function protectAccordionInItem(element) {
				if (element && element.querySelector) {
					const dashbox = element.querySelector('.dashbox');
					if (dashbox) {
						addAccordionToDashbox(dashbox);
					}
				}
			}

			// front/back 아이콘 업데이트 함수
			function updateFrontBackIcon() {
				const toggleAllFrontBackBtn = document.getElementById('toggleAllFrontBack');
				if (!toggleAllFrontBackBtn) return;
				
				// 모든 dashbox 확인
				const allDashboxes = document.querySelectorAll('.dashbox');
				let allBackVisible = true;
				let hasFrontBack = false;
				
				allDashboxes.forEach(function(dashbox) {
					const accordion = dashbox.querySelector('.accordion');
					if (accordion) {
						const frontElement = accordion.querySelector('.front');
						const backElement = accordion.querySelector('.back');
						
						if (frontElement && backElement) {
							hasFrontBack = true;
							// back이 보이는지 확인
							const isBackVisible = backElement.classList.contains('show') && 
												  backElement.style.visibility !== 'hidden' && 
												  backElement.style.opacity !== '0';
							
							if (!isBackVisible) {
								allBackVisible = false;
							}
						}
					}
				});
				
				// front/back이 있는 dashbox가 있고 모두 back이 보이면 chart-column 아이콘, 아니면 table-cells 아이콘
				if (hasFrontBack && allBackVisible) {
					toggleAllFrontBackBtn.className = 'fa-solid fa-chart-column head-icon';
				} else {
					toggleAllFrontBackBtn.className = 'fa-solid fa-table-cells head-icon';
				}
			}
			
			// front/back 화면 전환 함수
			function toggleFrontBack(element) {
				const frontElement = element.querySelector('.front');
				const backElement = element.querySelector('.back');
				
				if (!frontElement || !backElement) return;
				
				// 현재 상태 확인 (back이 보이는지 확인)
				const isBackVisible = backElement.classList.contains('show') && 
									  backElement.style.visibility !== 'hidden' && 
									  backElement.style.opacity !== '0';
				
				if (isBackVisible) {
					// back에서 front로 전환
					backElement.classList.remove('show');
					backElement.style.visibility = 'hidden';
					backElement.style.opacity = '0';
					backElement.style.pointerEvents = 'none';
					
					frontElement.style.visibility = 'visible';
					frontElement.style.opacity = '1';
					frontElement.style.pointerEvents = 'auto';
					frontElement.classList.remove('hide');
					frontElement.style.position = 'relative';
					frontElement.style.transform = 'translateY(0)';
					
					// front로 전환한 경우 즉시 저장
					setTimeout(function() {
						const saved = saveDashboardState();
						if (saved) {
							console.log('💾 자동 저장 완료 (Front/Back 전환)');
						}
						// 아이콘 업데이트
						updateFrontBackIcon();
					}, 50);
				} else {
					// front에서 back으로 전환
					frontElement.classList.add('hide');
					frontElement.style.position = 'absolute';
					frontElement.style.top = '0';
					frontElement.style.left = '0';
					frontElement.style.width = '100%';
					frontElement.style.height = '100%';
					frontElement.style.visibility = 'hidden';
					frontElement.style.opacity = '0';
					frontElement.style.pointerEvents = 'none';
					frontElement.style.transform = 'translateY(-10px)';
					
					backElement.style.position = 'absolute';
					backElement.style.top = '0';
					backElement.style.left = '0';
					backElement.style.width = '100%';
					backElement.style.height = '100%';
					backElement.style.visibility = 'visible';
					backElement.style.pointerEvents = 'auto';
					backElement.style.transform = 'translateY(0)';
					
					setTimeout(() => {
						backElement.classList.add('show');
						backElement.style.opacity = '1';
						
						// 상태 변경 완료 후 저장
						setTimeout(function() {
							const saved = saveDashboardState();
							if (saved) {
								console.log('💾 자동 저장 완료 (Front/Back 상태 변경)');
							}
							// 아이콘 업데이트
							updateFrontBackIcon();
						}, 50);
					}, 10);
				}
			}
			
			// 모든 front/back 요소에 클릭 이벤트 추가 (타이틀에서 전환)
			function initializeFrontBackToggle() {
				// .dash-title에 클릭 이벤트 추가
				document.querySelectorAll('.dash-title').forEach(function(titleElement) {
					titleElement.addEventListener('click', function(e) {
						e.preventDefault();
						e.stopPropagation();
						
						// 부모 dashbox에서 accordion 요소 찾기
						const dashbox = titleElement.closest('.dashbox');
						if (dashbox) {
							const accordion = dashbox.querySelector('.accordion');
							if (accordion && accordion.querySelector('.front') && accordion.querySelector('.back')) {
								console.log('Toggling front/back for accordion:', accordion);
								toggleFrontBack(accordion);
							}
						}
					});
					
					// 타이틀에 클릭 가능한 스타일 추가
					titleElement.style.cursor = 'pointer';
				});
				
				// front/back 요소의 클릭 이벤트 제거 (그래프 영역 클릭 비활성화)
				document.querySelectorAll('.front, .back').forEach(function(element) {
					element.style.cursor = 'default';
					element.removeEventListener('click', function() {});
				});
				
				// 디버깅을 위한 로그 추가
				console.log('Front/back toggle initialized for', document.querySelectorAll('.dash-title').length, 'titles');
			}

			// 그래프 초기화 함수들
			document.addEventListener('DOMContentLoaded', function() {
				console.log('Dashboard Demo 2 - Initializing charts...');
				
				// Chart.js 라이브러리 로드 확인
				if (typeof Chart === 'undefined') {
					console.error('Chart.js library not loaded');
					return;
				}
				
				// CSS 변수 값을 가져오는 헬퍼 함수
				const getCSSVariable = (variableName) => {
					// body 요소에서 먼저 확인 (bgcolor 클래스가 body에 적용됨)
					const bodyValue = getComputedStyle(document.body).getPropertyValue(variableName).trim();
					if (bodyValue) return bodyValue;
					// 없으면 documentElement에서 확인
					return getComputedStyle(document.documentElement).getPropertyValue(variableName).trim();
				};
				
				// 텍스트 색상 가져오기 (--c-text 사용)
				const textColor = getCSSVariable('--c-text') || '#ffffff';
				
				// 그래프 색상 가져오기 헬퍼 함수
				const getChartColor = (colorType, opacity = 1) => {
					const colorMap = {
						PRIMARY: '--chart-primary',
						SECONDARY: '--chart-secondary',
						TERTIARY: '--chart-tertiary',
						DANGER: '--chart-danger',
						WARNING: '--chart-warning',
						SUCCESS: '--chart-success',
						INFO: '--chart-info'
					};
					
					const fallbackMap = {
						PRIMARY: 'rgba(54, 162, 235, 1)',
						SECONDARY: 'rgba(75, 192, 192, 1)',
						TERTIARY: 'rgba(153, 102, 255, 1)',
						DANGER: 'rgba(255, 99, 132, 1)',
						WARNING: 'rgba(255, 159, 64, 1)',
						SUCCESS: 'rgba(75, 192, 192, 1)',
						INFO: 'rgba(54, 162, 235, 1)'
					};
					
					const cssVar = colorMap[colorType];
					const fallback = fallbackMap[colorType] || 'rgba(54, 162, 235, 1)';
					
					let color = getCSSVariable(cssVar) || fallback;
					
					// opacity가 1이 아니면 rgba로 변환
					if (opacity !== 1 && color) {
						// hex 색상을 rgba로 변환
						if (color.startsWith('#')) {
							const hex = color.replace('#', '');
							const r = parseInt(hex.substr(0, 2), 16);
							const g = parseInt(hex.substr(2, 2), 16);
							const b = parseInt(hex.substr(4, 2), 16);
							color = `rgba(${r}, ${g}, ${b}, ${opacity})`;
						} else if (color.startsWith('rgba')) {
							// rgba에서 opacity만 변경 (더 정확한 정규식)
							const match = color.match(/rgba?\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*[\d.]+)?\s*\)/);
							if (match) {
								color = `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${opacity})`;
							}
						} else if (color.startsWith('rgb')) {
							// rgb를 rgba로 변환
							const match = color.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/);
							if (match) {
								color = `rgba(${match[1]}, ${match[2]}, ${match[3]}, ${opacity})`;
							}
						}
					}
					
					return color;
				};
				
				// 간단하고 안정적인 차트 초기화 함수
				const initAllCharts = () => {
					// 기존 차트 인스턴스 제거
					if (typeof Chart !== 'undefined') {
						Chart.helpers.each(Chart.instances, (instance) => {
							instance.destroy();
						});
					}
					console.log('Starting chart initialization...');
					
					// 기본 선그래프 생성 함수
					const createBasicLineChart = (elementId, data, label, color = '#36a2eb', borderWidth = 2) => {
						const ctx = document.getElementById(elementId);
						if (!ctx) {
							console.warn(`Element ${elementId} not found`);
							return null;
						}
						
						// 기존 차트가 있으면 제거
						const existingChart = Chart.getChart(ctx);
						if (existingChart) {
							existingChart.destroy();
						}
						
					// 색상에 투명도 추가 (rgba 형식으로 변환)
					const applyOpacity = (colorStr, opacity) => {
						if (!colorStr) return colorStr;
						// rgba 형식인 경우
						if (colorStr.includes('rgba')) {
							return colorStr.replace(/[\d\.]+\)$/, opacity + ')');
						}
						// hex 형식인 경우
						if (colorStr.startsWith('#')) {
							const hex = colorStr.slice(1);
							const r = parseInt(hex.slice(0, 2), 16);
							const g = parseInt(hex.slice(2, 4), 16);
							const b = parseInt(hex.slice(4, 6), 16);
							return `rgba(${r}, ${g}, ${b}, ${opacity})`;
						}
						// rgb 형식인 경우
						if (colorStr.includes('rgb(')) {
							return colorStr.replace('rgb(', 'rgba(').replace(')', `, ${opacity})`);
						}
						return colorStr;
					};
					const backgroundColor = applyOpacity(color, 0.2); // 20% 투명도
						
						try {
							return new Chart(ctx, {
								type: 'line',
								data: {
									labels: ['09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'],
									datasets: [{
										label: label,
										data: data,
										borderColor: color,
										backgroundColor: backgroundColor,
										borderWidth: borderWidth,
										tension: 0.4,
										fill: true,
										pointBackgroundColor: color,
										pointBorderColor: color,
										pointBorderWidth: 0,
										pointRadius: 2,
										pointHoverRadius: 4
									}]
								},
								options: {
									responsive: true,
									maintainAspectRatio: false,
									plugins: {
										legend: { display: false }
									},
									scales: {
										x: {
											display: true,
											grid: { color: 'rgba(160, 160, 160, 0.3)' },
											ticks: { color: textColor, font: { size: 11 } }
										},
										y: {
											display: true,
											grid: { color: 'rgba(160, 160, 160, 0.3)' },
											ticks: { display: false }
										}
									}
								}
							});
						} catch (error) {
							console.error(`Error creating chart for ${elementId}:`, error);
							return null;
						}
					};
					
					// 3개 선 그래프 생성 함수
					const createMultiLineChart = (elementId, datasets, options = {}) => {
						const ctx = document.getElementById(elementId);
						if (!ctx) {
							console.warn(`Element ${elementId} not found`);
							return null;
						}
						
						// 기존 차트가 있으면 제거
						const existingChart = Chart.getChart(ctx);
						if (existingChart) {
							existingChart.destroy();
						}
						
						// 옵션 기본값
						const fill = options.fill !== undefined ? options.fill : false;
						const backgroundColorOpacity = options.backgroundColorOpacity !== undefined ? options.backgroundColorOpacity : 0.2;
						const borderWidth = options.borderWidth !== undefined ? options.borderWidth : 1;
						
						// 색상 투명도 적용 헬퍼 함수
						const applyOpacity = (colorStr, opacity) => {
							if (!colorStr) return colorStr;
							// rgba 형식인 경우 - 투명도만 교체
							if (colorStr.includes('rgba')) {
								return colorStr.replace(/rgba\(([^)]+)\)/, (match, content) => {
									const parts = content.split(',').map(s => s.trim());
									if (parts.length === 4) {
										return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${opacity})`;
									}
									return match;
								});
							}
							// hex 형식인 경우
							if (colorStr.startsWith('#')) {
								const hex = colorStr.slice(1);
								let r, g, b;
								if (hex.length === 3) {
									r = parseInt(hex[0] + hex[0], 16);
									g = parseInt(hex[1] + hex[1], 16);
									b = parseInt(hex[2] + hex[2], 16);
								} else {
									r = parseInt(hex.slice(0, 2), 16);
									g = parseInt(hex.slice(2, 4), 16);
									b = parseInt(hex.slice(4, 6), 16);
								}
								return `rgba(${r}, ${g}, ${b}, ${opacity})`;
							}
							// rgb 형식인 경우
							if (colorStr.includes('rgb(')) {
								return colorStr.replace('rgb(', 'rgba(').replace(')', `, ${opacity})`);
							}
							return colorStr;
						};
						
						try {
							return new Chart(ctx, {
								type: 'line',
								data: {
									labels: ['09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'],
									datasets: datasets.map(dataset => ({
										label: dataset.label,
										data: dataset.data,
										borderColor: dataset.color,
										backgroundColor: applyOpacity(dataset.color, backgroundColorOpacity),
										borderWidth: dataset.borderWidth || borderWidth,
										tension: 0.4,
										fill: fill,
										pointBackgroundColor: dataset.color,
										pointBorderColor: dataset.color,
										pointBorderWidth: 0,
										pointRadius: 2,
										pointHoverRadius: 4
									}))
								},
								options: {
									responsive: true,
									maintainAspectRatio: false,
									plugins: {
										legend: { 
											display: true,
											position: 'bottom',
											labels: {
												color: textColor,
												font: { size: 11 },
												usePointStyle: true,
												pointStyle: 'circle',
												boxWidth: 6,
												boxHeight: 6,
												padding: 10
											}
										}
									},
									scales: {
										x: {
											display: true,
											grid: { color: 'rgba(160, 160, 160, 0.3)' },
											ticks: { color: textColor, font: { size: 11 } }
										},
										y: {
											display: true,
											grid: { color: 'rgba(160, 160, 160, 0.3)' },
											ticks: { color: textColor, font: { size: 11 } }
										}
									}
								}
							});
						} catch (error) {
							console.error(`Error creating chart for ${elementId}:`, error);
							return null;
						}
					};
					
					// 기본 원형 그래프 생성 함수
					const createBasicDoughnutChart = (elementId, data, labels) => {
						const ctx = document.getElementById(elementId);
						if (!ctx) {
							console.warn(`Element ${elementId} not found`);
							return null;
						}
						
						// 기존 차트가 있으면 제거
						const existingChart = Chart.getChart(ctx);
						if (existingChart) {
							existingChart.destroy();
						}
						
						try {
							return new Chart(ctx, {
								type: 'doughnut',
								data: {
									labels: labels,
									datasets: [{
										data: data,
										backgroundColor: [
											getChartColor('PRIMARY', 0.8),
											getChartColor('SECONDARY', 0.8),
											getChartColor('TERTIARY', 0.8),
											getChartColor('DANGER', 0.8),
											getChartColor('WARNING', 0.8),
											getChartColor('SUCCESS', 0.8),
											getChartColor('INFO', 0.8),
											getChartColor('PRIMARY', 0.6),
											getChartColor('SECONDARY', 0.6)
										],
										borderColor: 'rgba(255, 255, 255, 0.1)',
										borderWidth: 2,
										hoverOffset: 4
									}]
								},
								options: {
									responsive: true,
									maintainAspectRatio: true,
									cutout: '70%',
									plugins: {
										legend: {
											display: true,
											position: 'bottom',
											labels: {
												color: textColor,
												font: { size: 12 },
												usePointStyle: true,
												pointStyle: 'circle',
												boxWidth: 6,
												boxHeight: 6,
												padding: 12
											}
										}
									}
								}
							});
						} catch (error) {
							console.error(`Error creating doughnut chart for ${elementId}:`, error);
							return null;
						}
					};
					
					// 시스템 리소스 통합 차트 생성 함수
					const createSystemResourceChart = (elementId) => {
						const ctx = document.getElementById(elementId);
						if (!ctx) {
							console.warn(`Element ${elementId} not found`);
							return null;
						}
						
						// 기존 차트가 있으면 제거
						const existingChart = Chart.getChart(ctx);
						if (existingChart) {
							existingChart.destroy();
						}
						
						try {
							return new Chart(ctx, {
								type: 'line',
								data: {
									labels: ['09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'],
									datasets: [
										{
											label: 'CPU',
											data: [65, 70, 75, 80, 85, 89, 87, 82, 78, 75, 72, 70],
											borderColor: getChartColor('PRIMARY', 1),
											backgroundColor: getChartColor('PRIMARY', 0.2),
											borderWidth: 1,
											tension: 0.4,
											fill: true,
											pointBackgroundColor: getChartColor('PRIMARY', 1),
											pointBorderColor: getChartColor('PRIMARY', 1),
											pointBorderWidth: 0,
											pointRadius: 2,
											pointHoverRadius: 4
										},
										{
											label: 'MEM',
											data: [20, 22, 25, 23, 21, 25, 24, 22, 20, 18, 19, 21],
											borderColor: getChartColor('SECONDARY', 1),
											backgroundColor: getChartColor('SECONDARY', 0.2),
											borderWidth: 1,
											tension: 0.4,
											fill: true,
											pointBackgroundColor: getChartColor('SECONDARY', 1),
											pointBorderColor: getChartColor('SECONDARY', 1),
											pointBorderWidth: 0,
											pointRadius: 2,
											pointHoverRadius: 4
										},
										{
											label: 'HDD',
											data: [15, 18, 20, 17, 16, 19, 18, 17, 15, 14, 16, 18],
											borderColor: getChartColor('TERTIARY', 1),
											backgroundColor: getChartColor('TERTIARY', 0.2),
											borderWidth: 1,
											tension: 0.4,
											fill: true,
											pointBackgroundColor: getChartColor('TERTIARY', 1),
											pointBorderColor: getChartColor('TERTIARY', 1),
											pointBorderWidth: 0,
											pointRadius: 2,
											pointHoverRadius: 4
										}
									]
								},
								options: {
									responsive: true,
									maintainAspectRatio: false,
									interaction: {
										mode: 'index',
										intersect: false,
									},
									plugins: {
										legend: {
											display: true,
											position: 'bottom',
											labels: {
												color: textColor,
												font: { size: 12 },
												usePointStyle: true,
												pointStyle: 'circle',
												boxWidth: 6,
												boxHeight: 6,
												padding: 12
											}
										},
										tooltip: {
											enabled: true,
											mode: 'index',
											intersect: false,
											backgroundColor: 'rgba(0, 0, 0, 0.9)',
											titleColor: '#FFF',
											bodyColor: '#FFF',
											borderColor: 'rgba(255, 255, 255, 0.3)',
											borderWidth: 1,
											cornerRadius: 8,
											displayColors: true,
											titleFont: { size: 12, weight: 'bold' },
											bodyFont: { size: 11 },
											padding: 12,
											callbacks: {
												title: function(context) {
													return '시간: ' + context[0].label + '시';
												},
												label: function(context) {
													return context.dataset.label + ': ' + context.parsed.y + '%';
												}
											}
										}
									},
									scales: {
										x: {
											display: true,
											grid: { color: 'rgba(160, 160, 160, 0.3)' },
											ticks: { color: textColor, font: { size: 11 } }
										},
										y: {
											display: true,
											min: 0,
											max: 100,
											grid: { color: 'rgba(160, 160, 160, 0.3)' },
											ticks: { display: false }
										}
									}
								}
							});
						} catch (error) {
							console.error(`Error creating chart for ${elementId}:`, error);
							return null;
						}
					};
					
					// 각 차트 초기화
					try {
						// 시스템 리소스 통합 차트
						console.log('Initializing system resource chart...');
						
						if (document.getElementById('systemResourceChart')) {
							createSystemResourceChart('systemResourceChart');
							console.log('✓ System Resource Chart initialized');
						}
						
					// IAM 트래픽 원그래프 (접속/차단)
					if (document.getElementById('iamTrafficDoughnutChart')) {
						const ctx = document.getElementById('iamTrafficDoughnutChart');
						if (ctx) {
							// 기존 차트가 있으면 제거
							const existingChart = Chart.getChart(ctx);
							if (existingChart) {
								existingChart.destroy();
							}
							const chart = new Chart(ctx, {
								type: 'doughnut',
								data: {
									labels: ['접속', '차단'],
									datasets: [{
										data: [1943, 45],
										backgroundColor: [
											getChartColor('PRIMARY', 0.8),  // 접속 - 파란색
											getChartColor('DANGER', 0.8)  // 차단 - 빨간색
										],
										borderColor: 'rgba(255, 255, 255, 0.1)',
										borderWidth: 2
									}]
								},
								options: {
									responsive: true,
									maintainAspectRatio: false,
									cutout: '70%',
									plugins: {
										legend: {
											display: true,
											position: 'bottom',
											labels: {
												color: textColor,
												font: { size: 12 },
												usePointStyle: true,
												pointStyle: 'circle',
												boxWidth: 6,
												boxHeight: 6,
												padding: 8
											}
										}
									}
								}
							});
							// 전역 변수에 차트 인스턴스 저장
							window.iamTrafficDoughnutChart = chart;
						}
						console.log('✓ IAM Traffic Doughnut Chart initialized');
					}
						
					// IAM 트래픽 차트 (사용자 접속현황 - 접속자 수, 접속 차단 수)
					if (document.getElementById('iamTrafficChart')) {
						const primaryColor = getChartColor('PRIMARY');
						const dangerColor = getChartColor('DANGER');
						const chart = createMultiLineChart('iamTrafficChart', [
							{
								label: '접속자 수',
								data: [1983, 1850, 1920, 2100, 2080, 1983, 1950, 2000, 1900, 2050, 1980, 2020],
								color: primaryColor
							},
							{
								label: '접속 차단 수',
								data: [45, 38, 52, 41, 48, 45, 42, 39, 44, 47, 43, 46],
								color: dangerColor
							}
						], {
							fill: true,
							backgroundColorOpacity: 0.15,
							borderWidth: 1,
							showLegend: true
						});
						// 전역 변수에 차트 인스턴스 저장
						window.iamTrafficChart = chart;
						
						// 범례 클릭 이벤트 핸들러 등록 (차트 초기화 후 약간의 지연을 두어 실행)
						setTimeout(function() {
							if (window.syncTableFilterFromLegend && window.iamTrafficChart) {
								window.syncTableFilterFromLegend(window.iamTrafficChart, 'userAccess');
							}
						}, 100);
						
						console.log('✓ IAM Traffic Chart initialized (접속자 수, 접속 차단 수)');
					}
						
						// ZTNA 트래픽 원그래프 (접속/차단)
						if (document.getElementById('ztnaTrafficDoughnutChart')) {
							const ctx = document.getElementById('ztnaTrafficDoughnutChart');
							if (ctx) {
								// 기존 차트가 있으면 제거
								const existingChart = Chart.getChart(ctx);
								if (existingChart) {
									existingChart.destroy();
								}
								const chart = new Chart(ctx, {
									type: 'doughnut',
									data: {
										labels: ['접속', '차단'],
										datasets: [{
											data: [1123, 121],
											backgroundColor: [
												getChartColor('PRIMARY', 0.8),  // 접속 - 파란색
												getChartColor('DANGER', 1)  // 차단 - 빨간색
											],
											borderColor: 'rgba(255, 255, 255, 0.1)',
											borderWidth: 2
										}]
									},
									options: {
										responsive: true,
										maintainAspectRatio: false,
										cutout: '70%',
										plugins: {
											legend: {
												display: true,
												position: 'bottom',
												labels: {
													color: textColor,
													font: { size: 12 },
													usePointStyle: true,
													pointStyle: 'circle',
													boxWidth: 6,
													boxHeight: 6,
													padding: 8
												}
											}
										}
									}
								});
								// 전역 변수에 차트 인스턴스 저장
								window.ztnaTrafficDoughnutChart = chart;
							}
							console.log('✓ ZTNA Traffic Doughnut Chart initialized');
						}
						
					// ZTNA 트래픽 차트 (VPN 외부접속자 현황 - 접속자 수, 접속 차단 수)
					if (document.getElementById('ztnaTrafficChart')) {
						const primaryColor = getChartColor('PRIMARY');
						const dangerColor = getChartColor('DANGER');
						const chart = createMultiLineChart('ztnaTrafficChart', [
							{
								label: '접속자 수',
								data: [1211, 1150, 1180, 1250, 1220, 1211, 1190, 1200, 1180, 1230, 1200, 1215],
								color: primaryColor
							},
							{
								label: '접속 차단 수',
								data: [32, 28, 35, 30, 25, 32, 29, 33, 27, 31, 34, 30],
								color: dangerColor
							}
						], {
							fill: true,
							backgroundColorOpacity: 0.15,
							borderWidth: 1,
							showLegend: true
						});
						// 전역 변수에 차트 인스턴스 저장
						window.ztnaTrafficChart = chart;
						
						// 범례 클릭 이벤트 핸들러 등록 (차트 초기화 후 약간의 지연을 두어 실행)
						setTimeout(function() {
							if (window.syncTableFilterFromLegend && window.ztnaTrafficChart) {
								window.syncTableFilterFromLegend(window.ztnaTrafficChart, 'vpnAccess');
							}
						}, 100);
						
						console.log('✓ ZTNA Traffic Chart initialized (접속자 수, 접속 차단 수)');
					}
						
					// 정보유출 감시현황 누적막대 그래프 (허용 수, 차단 수)
					if (document.getElementById('infoLeakChart')) {
						const primaryColor = getChartColor('PRIMARY');
						const dangerColor = getChartColor('DANGER');
						const chart = createStackedBarChart('infoLeakChart', [
							createBarDataset('허용 수', [1543, 1520, 1500, 1543, 1520, 1480, 1460, 1440, 1420, 1400, 1380, 1360], primaryColor),
							createBarDataset('차단 수', [440, 430, 420, 440, 430, 420, 420, 410, 400, 400, 400, 390], dangerColor)
						], {
							stacked: true,
							barPercentage: 0.25,
							showLegend: true
						});
						// 전역 변수에 차트 인스턴스 저장
						window.infoLeakChart = chart;
						
						// 범례 클릭 이벤트 핸들러 등록 (차트 초기화 후 약간의 지연을 두어 실행)
						setTimeout(function() {
							if (window.syncTableFilterFromLegend && window.infoLeakChart) {
								window.syncTableFilterFromLegend(window.infoLeakChart, 'infoLeak');
							}
						}, 100);
						
						console.log('✓ Info Leak Chart initialized (허용 수, 차단 수) - 누적막대 그래프');
					}
						
					// 시스템 트래픽 현황 차트 (3개 선 그래프: SWG, VPN, DLP)
					if (document.getElementById('ztnaBlockChart')) {
						// 차트 색상 변수 정의 (시스템 리소스 차트와 동일한 스타일)
						const swgColor = getChartColor('PRIMARY', 1);
						const vpnColor = getChartColor('SECONDARY', 1);
						const dlpColor = getChartColor('TERTIARY', 1);
						
						// IN/OUT 데이터 정의
						window.systemTrafficData = {
							IN: {
								SWG: { value: 1943, data: [1943, 1850, 1920, 2100, 2080, 1943, 1950, 2000, 1900, 2050, 1980, 2020] },
								VPN: { value: 1943, data: [1943, 1800, 1880, 2050, 2030, 1943, 1920, 1980, 1880, 2020, 1950, 2000] },
								DLP: { value: 112, data: [112, 105, 110, 120, 115, 112, 108, 118, 105, 125, 110, 115] }
							},
							OUT: {
								SWG: { value: 650, data: [650, 580, 620, 750, 720, 1650, 1680, 700, 600, 730, 680, 710] },
								VPN: { value: 1520, data: [1520, 1450, 1500, 1620, 1580, 1520, 1550, 1600, 1480, 1630, 1570, 1610] },
								DLP: { value: 95, data: [95, 88, 92, 102, 98, 95, 90, 100, 88, 105, 92, 97] }
							}
						};
						
						// 초기 차트 생성 (IN 데이터로)
						const chart = createMultiLineChart('ztnaBlockChart', [
							{
								label: 'SWG',
								data: window.systemTrafficData.IN.SWG.data,
								color: swgColor
							},
							{
								label: 'VPN',
								data: window.systemTrafficData.IN.VPN.data,
								color: vpnColor
							},
							{
								label: 'DLP',
								data: window.systemTrafficData.IN.DLP.data,
								color: dlpColor
							}
						], {
							fill: true,
							backgroundColorOpacity: 0.2,
							borderWidth: 1
						});
						
						// 전역 변수에 차트 인스턴스 저장
						window.ztnaBlockChart = chart;
						
						// IN/OUT 클릭 이벤트 리스너 추가
						setTimeout(function() {
							const systemTrafficBox = Array.from(document.querySelectorAll('.dash-title')).find(el => el.textContent.includes('시스템 트래픽 현황'))?.closest('.dashbox');
							if (systemTrafficBox) {
								const demotable = systemTrafficBox.querySelector('.demotable');
								if (demotable) {
									// 텍스트 내용으로 IN/OUT span 찾기
									const allSpans = demotable.querySelectorAll('span.demofont');
									let inSpan = null, outSpan = null;
									
									allSpans.forEach(span => {
										if (span.textContent.trim() === 'IN') {
											inSpan = span;
										} else if (span.textContent.trim() === 'OUT') {
											outSpan = span;
										}
									});
									
									if (inSpan && outSpan) {
										// IN 클릭 이벤트
										inSpan.style.cursor = 'pointer';
										inSpan.addEventListener('click', function(e) {
											e.stopPropagation();
											updateSystemTraffic('IN');
										});
										
										// OUT 클릭 이벤트
										outSpan.style.cursor = 'pointer';
										outSpan.addEventListener('click', function(e) {
											e.stopPropagation();
											updateSystemTraffic('OUT');
										});
									}
								}
							}
						}, 100);
						
						console.log('✓ System Traffic Chart initialized (SWG, VPN, DLP)');
					}
					
					// 시스템 트래픽 IN/OUT 업데이트 함수
					window.updateSystemTraffic = function(type) {
						if (!window.systemTrafficData || !window.ztnaBlockChart) return;
						
						const data = window.systemTrafficData[type];
						if (!data) return;
						
						// 스타일 업데이트
						const systemTrafficBox = Array.from(document.querySelectorAll('.dash-title')).find(el => el.textContent.includes('시스템 트래픽 현황'))?.closest('.dashbox');
						if (systemTrafficBox) {
							const demotable = systemTrafficBox.querySelector('.demotable');
							if (demotable) {
								// 텍스트 내용으로 IN/OUT span 찾기
								const allSpans = demotable.querySelectorAll('span.demofont');
								let inSpan = null, outSpan = null;
								
								allSpans.forEach(span => {
									if (span.textContent.trim() === 'IN') {
										inSpan = span;
									} else if (span.textContent.trim() === 'OUT') {
										outSpan = span;
									}
								});
								
								if (inSpan && outSpan) {
									if (type === 'IN') {
										inSpan.classList.remove('off');
										outSpan.classList.add('off');
									} else {
										inSpan.classList.add('off');
										outSpan.classList.remove('off');
									}
								}
								
								// 수치 업데이트 - 테이블 구조에 맞게 찾기
								const allTds = Array.from(demotable.querySelectorAll('td'));
								let swgValueCell = null, vpnValueCell = null, dlpValueCell = null;
								
								allTds.forEach((td, idx) => {
									const text = td.textContent.trim();
									if (text === 'SWG' && idx + 1 < allTds.length) {
										swgValueCell = allTds[idx + 1];
									}
									if (text === 'VPN' && idx + 1 < allTds.length) {
										vpnValueCell = allTds[idx + 1];
									}
									if (text === 'DLP' && idx + 1 < allTds.length) {
										dlpValueCell = allTds[idx + 1];
									}
								});
								
								if (swgValueCell) {
									swgValueCell.textContent = data.SWG.value.toLocaleString();
								}
								if (vpnValueCell) {
									vpnValueCell.textContent = data.VPN.value.toLocaleString();
								}
								if (dlpValueCell) {
									dlpValueCell.textContent = data.DLP.value.toLocaleString();
								}
							}
						}
						
						// 차트 업데이트
						window.ztnaBlockChart.data.datasets[0].data = data.SWG.data;
						window.ztnaBlockChart.data.datasets[1].data = data.VPN.data;
						window.ztnaBlockChart.data.datasets[2].data = data.DLP.data;
						
						window.ztnaBlockChart.update();
					};
						
					// 사이트 접속현황 누적막대 그래프 (허용 수, 차단 수)
					if (document.getElementById('siteAccessChart')) {
						const primaryColor = getChartColor('PRIMARY');
						const dangerColor = getChartColor('DANGER');
						const chart = createStackedBarChart('siteAccessChart', [
							createBarDataset('허용 수', [1222, 1200, 1180, 1250, 1230, 1222, 1210, 1220, 1200, 1240, 1215, 1225], primaryColor),
							createBarDataset('차단 수', [123, 115, 120, 130, 125, 123, 118, 122, 120, 128, 125, 123], dangerColor)
						], {
							stacked: true,
							barPercentage: 0.25,
							showLegend: true
						});
						// 전역 변수에 차트 인스턴스 저장
						window.siteAccessChart = chart;
						
						// 범례 클릭 이벤트 핸들러 등록 (차트 초기화 후 약간의 지연을 두어 실행)
						setTimeout(function() {
							if (window.syncTableFilterFromLegend && window.siteAccessChart) {
								window.syncTableFilterFromLegend(window.siteAccessChart, 'siteAccess');
							}
						}, 100);
						
						console.log('✓ Site Access Chart initialized (허용 수, 차단 수) - 누적막대 그래프');
					}
						
					// CASB 블록 차트 (정보 유출 의심 현황 - 막대+선 혼합형 그래프)
					if (document.getElementById('casbBlockChart')) {
						const ctx = document.getElementById('casbBlockChart');
						if (ctx) {
							// 기존 차트가 있으면 제거
							const existingChart = Chart.getChart(ctx);
							if (existingChart) {
								existingChart.destroy();
							}
							
							new Chart(ctx, {
								type: 'bar',
								data: {
									labels: ['09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '20'],
									datasets: [{
										label: '전체',
										data: [45, 38, 52, 41, 48, 45, 42, 39, 44, 47, 43, 46],
										borderColor: getChartColor('DANGER', 1),
										backgroundColor: getChartColor('DANGER', 0.2),
										borderWidth: 1,
										tension: 0.4,
										fill: false,
										pointBackgroundColor: getChartColor('DANGER', 1),
										pointBorderColor: getChartColor('DANGER', 1),
										pointBorderWidth: 0,
										pointRadius: 3,
										pointHoverRadius: 5,
										type: 'line'
									}, {
										label: '개인정보',
										data: [25, 22, 28, 24, 26, 25, 23, 21, 24, 27, 22, 26],
										backgroundColor: getChartColor('PRIMARY', 0.8),
										borderColor: getChartColor('PRIMARY', 1),
										borderWidth: 1,
										type: 'bar'
									}, {
										label: '키워드',
										data: [20, 16, 24, 17, 22, 20, 19, 18, 20, 23, 21, 20],
										backgroundColor: getChartColor('TERTIARY', 0.8),
										borderColor: getChartColor('TERTIARY', 1),
										borderWidth: 1,
										type: 'bar'
									}]
								},
								options: {
									responsive: true,
									maintainAspectRatio: false,
									aspectRatio: 2.5,
									layout: {
										padding: {
											bottom: 20
										}
									},
									interaction: {
										mode: 'index',
										intersect: false,
									},
									plugins: {
										legend: {
											display: true,
											position: 'bottom',
											labels: {
												color: textColor,
												font: {
													size: 12
												},
												usePointStyle: true,
												pointStyle: 'circle',
												boxWidth: 6,
												boxHeight: 6,
												padding: 6
											}
										},
										tooltip: {
											enabled: true,
											mode: 'index',
											intersect: false,
											backgroundColor: 'rgba(0, 0, 0, 0.9)',
											titleColor: '#ffffff',
											bodyColor: '#ffffff',
											borderColor: 'rgba(255, 255, 255, 0.3)',
											borderWidth: 1,
											cornerRadius: 8,
											displayColors: true,
											titleFont: {
												size: 12,
												weight: 'bold'
											},
											bodyFont: {
												size: 11
											},
											padding: 12,
											callbacks: {
												title: function(context) {
													return '시간: ' + context[0].label + '시';
												},
												label: function(context) {
													return context.dataset.label + ': ' + context.parsed.y + '건';
												}
											}
										}
									},
									scales: {
										x: {
											display: true,
											barPercentage: 0.5,
											grid: {
												color: 'rgba(160, 160, 160, 0.3)',
												drawBorder: false
											},
											ticks: {
												color: textColor,
												font: {
													size: 11
												}
											}
										},
										y: {
											display: true,
											beginAtZero: true,
											grid: {
												color: 'rgba(160, 160, 160, 0.3)',
												drawBorder: false
											},
											ticks: {
												color: textColor,
												font: {
													size: 11
												}
											}
										}
									}
								}
							});
						}
						console.log('✓ CASB Block Chart initialized (Mixed Chart: Line + Bar)');
					}
						
						// AI 총 사용량 차트
						if (document.getElementById('aiTotalUsageChart')) {
							createBasicDoughnutChart('aiTotalUsageChart', 
								[30, 28, 12, 5, 5, 5, 5, 5, 5],
								['프로토콜', '웹메일', '메신저', 'SNS', '댓글', '업무공유', '웹하드', 'FTP', 'WEB(POST)']);
							console.log('✓ AI Total Usage Chart initialized');
						}
						
						console.log('All charts initialized successfully!');
						
					} catch (error) {
						console.error('Error during chart initialization:', error);
					}
					
					// 차트 초기화 후 테마 적용
					if (typeof window.applyChartTheme === 'function') {
						setTimeout(() => {
							window.applyChartTheme();
						}, 200);
					}
				};
				
				// 차트 초기화 실행
				initAllCharts();
				
				// 전역으로 노출 (테마 변경 시 호출 가능하도록)
				window.initCharts = initAllCharts;
			});

			// 사용자 접속 현황 및 VPN 외부접속자 현황, 사이트 접속현황, 정보유출 감시현황 필터링 기능
			$(document).ready(function() {
				// 각 테이블별 필터 상태 추적
				const filterStates = {
					userAccess: {
						success: true,  // 접속자 수 (기본값: 선택됨)
						blocked: true   // 접속차단 수 (기본값: 선택됨)
					},
					vpnAccess: {
						success: true,  // 접속자 수 (기본값: 선택됨)
						blocked: true   // 접속차단 수 (기본값: 선택됨)
					},
					siteAccess: {
						success: true,  // 허용 수 (기본값: 선택됨)
						blocked: true   // 차단 수 (기본값: 선택됨)
					},
					infoLeak: {
						success: true,  // 허용 수 (기본값: 선택됨)
						blocked: true   // 차단 수 (기본값: 선택됨)
					}
				};
				
				// 테이블 ID와 필터 상태 매핑
				const tableFilterMap = {
					'userAccessTable': 'userAccess',
					'vpnAccessTable': 'vpnAccess',
					'siteAccessTable': 'siteAccess',
					'infoLeakTable': 'infoLeak'
				};
				
				// 필터 옵션 클릭 이벤트
				$('.filter-option').on('click', function(e) {
					e.stopPropagation(); // demofont 선택 기능과 충돌 방지
					
					const filterType = $(this).data('filter');
					const $option = $(this);
					
					// 클릭된 필터 옵션이 속한 테이블 찾기
					const $dashbox = $option.closest('.dashbox');
					let tableId = null;
					let filterKey = null;
					
					// 사용자 접속 현황 테이블인지 확인
					if ($dashbox.find('#userAccessTable').length > 0) {
						tableId = 'userAccessTable';
						filterKey = 'userAccess';
					}
					// VPN 외부접속자 현황 테이블인지 확인
					else if ($dashbox.find('#vpnAccessTable').length > 0) {
						tableId = 'vpnAccessTable';
						filterKey = 'vpnAccess';
					}
					// 사이트 접속현황 테이블인지 확인
					else if ($dashbox.find('#siteAccessTable').length > 0) {
						tableId = 'siteAccessTable';
						filterKey = 'siteAccess';
					}
					// 정보유출 차단현황 테이블인지 확인
					else if ($dashbox.find('#infoLeakTable').length > 0) {
						tableId = 'infoLeakTable';
						filterKey = 'infoLeak';
					}
					
					if (filterKey && tableId) {
						// 필터 상태 토글
						filterStates[filterKey][filterType] = !filterStates[filterKey][filterType];
						
						// 선택 상태 시각적 표시
						if (filterStates[filterKey][filterType]) {
							$option.addClass('selected');
						} else {
							$option.removeClass('selected');
						}
						
						// 해당 테이블 필터링 적용
						applyTableFilter(tableId, filterStates[filterKey]);
						
						// 차트 범례 업데이트
						updateChartLegend(filterKey, filterStates[filterKey]);
					}
				});
				
				// 테이블 필터링 함수
				function applyTableFilter(tableId, filterState) {
					const $table = $('#' + tableId);
					const $rows = $table.find('tbody tr');
					
					$rows.each(function() {
						const $row = $(this);
						const status = $row.data('status');
						
						// 필터 상태에 따라 행 표시/숨김
						if (filterState[status]) {
							$row.show();
						} else {
							$row.hide();
						}
					});
				}
				
				// 차트 범례 업데이트 함수 (테이블 필터 변경 시 차트 업데이트)
				function updateChartLegend(filterKey, filterState) {
					if (filterKey === 'userAccess') {
						// 사용자 접속현황 차트 업데이트
						// 라인 차트 (iamTrafficChart)
						if (window.iamTrafficChart) {
							const chart = window.iamTrafficChart;
							// success (접속자 수) -> 인덱스 0
							// blocked (접속차단 수) -> 인덱스 1
							if (chart.data.datasets[0]) {
								const meta0 = chart.getDatasetMeta(0);
								if (meta0) {
									meta0.hidden = !filterState.success;
								}
							}
							if (chart.data.datasets[1]) {
								const meta1 = chart.getDatasetMeta(1);
								if (meta1) {
									meta1.hidden = !filterState.blocked;
								}
							}
							chart.update();
						}
						// 원그래프 (iamTrafficDoughnutChart) - 범례는 그대로 유지 (필터링 없음)
					} else if (filterKey === 'vpnAccess') {
						// VPN 외부접속자 현황 차트 업데이트
						// 라인 차트 (ztnaTrafficChart)
						if (window.ztnaTrafficChart) {
							const chart = window.ztnaTrafficChart;
							// success (접속자 수) -> 인덱스 0
							// blocked (접속차단 수) -> 인덱스 1
							if (chart.data.datasets[0]) {
								const meta0 = chart.getDatasetMeta(0);
								if (meta0) {
									meta0.hidden = !filterState.success;
								}
							}
							if (chart.data.datasets[1]) {
								const meta1 = chart.getDatasetMeta(1);
								if (meta1) {
									meta1.hidden = !filterState.blocked;
								}
							}
							chart.update();
						}
						// 원그래프 (ztnaTrafficDoughnutChart) - 범례는 그대로 유지 (필터링 없음)
					} else if (filterKey === 'siteAccess') {
						// 사이트 접속현황 차트 업데이트
						// 누적막대 그래프 (siteAccessChart)
						if (window.siteAccessChart) {
							const chart = window.siteAccessChart;
							// success (허용 수) -> 인덱스 0
							// blocked (차단 수) -> 인덱스 1
							if (chart.data.datasets[0]) {
								const meta0 = chart.getDatasetMeta(0);
								if (meta0) {
									meta0.hidden = !filterState.success;
								}
							}
							if (chart.data.datasets[1]) {
								const meta1 = chart.getDatasetMeta(1);
								if (meta1) {
									meta1.hidden = !filterState.blocked;
								}
							}
							chart.update();
						}
					} else if (filterKey === 'infoLeak') {
						// 정보유출 차단현황 차트 업데이트
						// 누적막대 그래프 (infoLeakChart)
						if (window.infoLeakChart) {
							const chart = window.infoLeakChart;
							// success (허용 수) -> 인덱스 0
							// blocked (차단 수) -> 인덱스 1
							if (chart.data.datasets[0]) {
								const meta0 = chart.getDatasetMeta(0);
								if (meta0) {
									meta0.hidden = !filterState.success;
								}
							}
							if (chart.data.datasets[1]) {
								const meta1 = chart.getDatasetMeta(1);
								if (meta1) {
									meta1.hidden = !filterState.blocked;
								}
							}
							chart.update();
						}
					}
				}
				
				// 범례 클릭 시 테이블 필터 동기화 함수
				function syncTableFilterFromLegend(chart, filterKey) {
					if (!chart || !filterKey) return;
					
					// 차트의 범례 클릭 이벤트 핸들러 설정
					// Chart.js의 기본 onClick 동작을 사용
					const defaultOnClick = Chart.defaults.plugins.legend.onClick;
					
					chart.options.plugins.legend.onClick = function(e, legendItem, legend) {
						// 기본 동작 실행 (데이터셋 숨기기/보이기)
						// Chart.js의 기본 동작은 meta.hidden을 토글합니다
						defaultOnClick.call(this, e, legendItem, legend);
						
						// 차트 업데이트 (범례 취소선 표시를 위해)
						chart.update();
						
						// 테이블 필터 상태 동기화
						const datasetIndex = legendItem.datasetIndex;
						const dataset = chart.data.datasets[datasetIndex];
						const meta = chart.getDatasetMeta(datasetIndex);
						// Chart.js는 meta.hidden을 사용하므로 이를 확인
						const isHidden = meta.hidden === true;
						
						// 필터 타입 결정
						let filterType = null;
						if (dataset.label === '접속자 수' || dataset.label === '허용 수') {
							filterType = 'success';
						} else if (dataset.label === '접속 차단 수' || dataset.label === '차단 수') {
							filterType = 'blocked';
						}
						
						if (filterType && filterStates[filterKey]) {
							// 필터 상태 업데이트 (숨겨지지 않았으면 true)
							filterStates[filterKey][filterType] = !isHidden;
							
							// 테이블 필터 옵션 UI 업데이트
							let tableId = null;
							if (filterKey === 'userAccess') {
								tableId = 'userAccessTable';
							} else if (filterKey === 'vpnAccess') {
								tableId = 'vpnAccessTable';
							} else if (filterKey === 'siteAccess') {
								tableId = 'siteAccessTable';
							} else if (filterKey === 'infoLeak') {
								tableId = 'infoLeakTable';
							}
							
							if (tableId) {
								const $dashbox = $('#' + tableId).closest('.dashbox');
								const $filterOption = $dashbox.find('.filter-option[data-filter="' + filterType + '"]');
								
								if (filterStates[filterKey][filterType]) {
									$filterOption.addClass('selected');
								} else {
									$filterOption.removeClass('selected');
								}
								
								// 테이블 필터링 적용
								applyTableFilter(tableId, filterStates[filterKey]);
							}
						}
					};
				}
				
				// 전역으로 노출 (차트 초기화 시 사용)
				window.syncTableFilterFromLegend = syncTableFilterFromLegend;
				
				// 초기 상태 설정 (모두 선택된 상태)
				$('.filter-option').addClass('selected');
				
				// 초기 필터링 적용
				applyTableFilter('userAccessTable', filterStates.userAccess);
				applyTableFilter('vpnAccessTable', filterStates.vpnAccess);
				applyTableFilter('siteAccessTable', filterStates.siteAccess);
				applyTableFilter('infoLeakTable', filterStates.infoLeak);
				
				// 초기 차트 범례 업데이트 (약간의 지연을 두어 차트가 초기화된 후 실행)
				setTimeout(function() {
					updateChartLegend('userAccess', filterStates.userAccess);
					updateChartLegend('vpnAccess', filterStates.vpnAccess);
					updateChartLegend('siteAccess', filterStates.siteAccess);
					updateChartLegend('infoLeak', filterStates.infoLeak);
				}, 500);
			});
			
			// 특정 항목들에 커서 포인터 비활성화
			document.addEventListener('DOMContentLoaded', function() {
				// 서비스 접속현황의 프로토콜, 웹메일, 메신저
				const serviceAccessBox = Array.from(document.querySelectorAll('.dash-title')).find(el => el.textContent.includes('서비스별 접속 현황'))?.closest('.dashbox');
				if (serviceAccessBox) {
					const demotable = serviceAccessBox.querySelector('.demotable');
					if (demotable) {
						const tds = demotable.querySelectorAll('td');
						tds.forEach(td => {
							const text = td.textContent.trim();
							if (text === '프로토콜' || text === '웹메일' || text === '메신저' || text === '매신저') {
								td.style.cursor = 'default';
							}
						});
					}
				}
				
				// 정보 유출 감시현황의 전체, 개인정보, 키워드
				const infoLeakBox = Array.from(document.querySelectorAll('.dash-title')).find(el => el.textContent.includes('정보 유출 감시 현황'))?.closest('.dashbox');
				if (infoLeakBox) {
					const demotable = infoLeakBox.querySelector('.demotable');
					if (demotable) {
						const tds = demotable.querySelectorAll('td');
						tds.forEach(td => {
							const text = td.textContent.trim();
							if (text === '전체' || text === '개인정보' || text === '키워드') {
								td.style.cursor = 'default';
							}
						});
					}
				}
				
				// 시스템 트래픽 현황의 SWG, VPN, DLP
				const systemTrafficBox = Array.from(document.querySelectorAll('.dash-title')).find(el => el.textContent.includes('시스템 트래픽 현황'))?.closest('.dashbox');
				if (systemTrafficBox) {
					const demotable = systemTrafficBox.querySelector('.demotable');
					if (demotable) {
						const tds = demotable.querySelectorAll('td');
						tds.forEach(td => {
							const text = td.textContent.trim();
							if (text === 'SWG' || text === 'VPN' || text === 'DLP') {
								td.style.cursor = 'default';
							}
						});
					}
				}
			});
			
		</script>
	</body>
</html>